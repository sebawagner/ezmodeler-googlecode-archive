<?xml version="1.0" encoding="UTF-8" ?>
<library>


<class name="drawArrowWhiteBoard" resource="drawarrow_rsc" >
	<method name="setTint" args="color, brightness">
	    <![CDATA[
	    if (color != "" && color != null){
	        if (brightness == null) { brightness = 0; }
	        var rgb = color;
	        var red=(rgb >> 16) & 0xFF;
	        var green=(rgb >> 8) & 0xFF;
	        var blue=rgb & 0xFF;

	        this.setColorTransform( { ra : red, ga : green, ba : blue,
	                            		rb : 0, gb : 0, bb : 0 } );
	    }
	    ]]>
	</method>
</class>

<class name="baseDrawContent">
    
    <handler name="onmousedown" >
        this.dragArea.contentArea._currentBoard.onmousedownMethod();
    </handler>
    
    <handler name="onmouseup" >
        this.dragArea.contentArea._currentBoard.onmouseupMethod();
    </handler>
    
</class>


<!-- clickable="true" -->
<class name="baseDraw" extends="view">

	<attribute name="currentlayer" value="null" />
	<attribute name="layers" value="null" />
	
	<attribute name="redolayers" value="null" />
	
  	<attribute name="mx" type="number" value="0"/>
  	<attribute name="my" type="number" value="0"/>
  	<attribute name="prevx" type="number" value="0"/>
  	<attribute name="prevy" type="number" value="0"/>
  	
  	<!-- paint -->
  	<attribute name="currentlayerstroke" value="0xFF6600" />
  	<attribute name="currentlayerlineWidth" value="2" type="number" />
  	
  	<!-- for drawing line -->
  	<attribute name="currentlinestroke" value="0xFF6600" />
  	<attribute name="currentlinelineWidth" value="2" type="number" />  	
  	
  	<!-- for drawing uline -->
  	<attribute name="currentulinestroke" value="0xFF6600" />
  	<attribute name="currentulinelineWidth" value="2" type="number" />  
  	
  	<!-- for drawing drawarrow -->
  	<attribute name="currentdrawarrowlinestroke" value="0xFF6600" />
  	<attribute name="currentdrawarrowlinelineWidth" value="1" type="number" />    	
  	
  	<!--  
  		for drawing rectangles the variable 
  		with *Dis* indicates if the line/fil-color is active (+1/-1)
  	 -->
  	<attribute name="currentrectanglestroke" value="0xFF6600" />
  	<attribute name="currentrectanglestrokeDis" value="1" type="number" />
  	<attribute name="currentrectanglestrokeFill" value="0xFFFF33" />
  	<attribute name="currentrectanglestrokeFillDis" value="1" type="number" />
  	<attribute name="currentrectangleineWidth" value="4" type="number" />
  	
  	<!-- 
	  	for drawing ellipse the variable 
	  	with *Dis* indicates if the line/fil-color is active (+1/-1)
  	 -->
  	<attribute name="currentellipsestroke" value="0xFF6600" />
  	<attribute name="currentellipsestrokeDis" value="1" type="number" />
  	<attribute name="currentellipsestrokeFill" value="0xFFFF33" />
  	<attribute name="currentellipsestrokeFillDis" value="1" type="number" />
  	<attribute name="currentellipselineWidth" value="4" />
  	
  	<attribute name="painttrans" value="false" type="boolean" />
  	
  	<attribute name="startx" value="0" type="number" />
  	<attribute name="starty" value="0" type="number" />
  	<attribute name="endx" value="0" type="number" />
  	<attribute name="endy" value="0" type="number" />
    
    <attribute name="currentZoom" value="100" type="number" />
  	
  	<attribute name="initheight" value="0" type="number" />
  	<attribute name="initwidth" value="0" type="number" />
  	
  	<attribute name="currentOID" value="0" type="number" />
  	
  	<!--
  	 Needed to reset values again
  	 -->
  	<attribute name="startedDrawingProcess" value="false" type="boolean" />
  	
  	<!-- This Counter just adds, it dosen't shows the absolute number of items
  		(ask this.layers.length to get the number of drawings) -->
  	<attribute name="counter" value="0" type="number" />
  	
  	<!-- This shows if this Diagram is currently active in the User-Space -->
  	<attribute name="isActive" value="false" type="boolean" />
  	
  	<!-- indicates if the root is dragging -->
  	<attribute name="dragRoot" value="false" type="boolean" />
  	
  	<attribute name="previousModi" value="" type="string" />
  	
  	<!-- Current Selected Object -->
  	<attribute name="currentSelectedObjectName" value="" type="string" />

  	<method name="getCounter">
		//Debug.write("### getCounter :",this.counter);
  		var now = new Date();
  		return "_"+now.getTime();
  	</method>
	
	<method name="compareAndSetCounter" args="c">
		<![CDATA[
			if (c>this.counter) this.counter = c;
		]]>
	</method>
	
	<!--
	<method name="updateCurrentOID">
		this.getObjectIdentifier.doCall();
	</method>
	
    <netRemoteCallRPC name="getObjectIdentifier" funcname="getObjectIdentifier" 
    	remotecontext="$once{  canvas. }" >      
        <netparam><method name="getValue"> return canvas.currentdomainObj.organisation_id; </method></netparam> 
        <handler name="ondata" args="value">
            //The onResult-Handler will be called be the rtmpconnection
            //if ($debug) Debug.write("DRAWAREA getObjectIdentifier: ",value);
            parent.currentOID = value;
        </handler>  
    </netRemoteCallRPC> 	
     -->
  	
	<attribute name="mousetracker_del" value="$once{ new LzDelegate(this, 'trackmouse' )}" />
	
	<!-- 
	This is the very basic decision what to do
	the modus pointer is only  a temp modus which is inited while draging
	a new selected object
	 -->
	<attribute name="drawmodus" value="hand" type="string" />
	
	<!-- This List holds all ActionObject
		currently paintings
				  letters -->
	<attribute name="baseactionobjectList" value="null" />
	<attribute name="baseredoactionobjectList" value="null" />
	
	<!-- This List hold a reference to all 
		Array of Drawing Action, it is needed for coping the view and undo/redo -->
	<attribute name="basetempactionobjectList" value="null" />
	
	<attribute name="basdrawredoView" value="null" />
	
	<attribute name="hasprevious" value="false" type="boolean" />
	<attribute name="hasenext" value="false" type="boolean" />
	
	<!-- For the dragging resizeing there is a bounding box -->
	<attribute name="boundingIsActive" value="false" type="boolean" />
	<attribute name="boundingref" value="null" />
	
	<!-- For sending messages in shared modus -->
	<method name="onsharedMessage" args="action,obj">
        ////if ($debug) Debug.write("onsharedMessage NEW MESSAGE ",action,obj);
        
        this.turnOnSaveFlag();
        
    </method>
    
    <method name="turnOnSaveFlag">
    	//show Update Dialog but don't show it initially when all Objects are loaded 
        if (!this.isRemoteLoaderAction) {
            parent.parent.parent.parent.setAttribute('destroyByMethod',true);
        }
    </method>
	
	<!-- this event must be triggered AFTER
		the nesseccary room + domain for this conferenceView is set
		-->
	<event name="onopenWhiteBoard" />
	
	<attribute name="isOptionMenu" type="boolean" value="false" />
    
    <handler name="oninit">
        //Add Help Item
        canvas.addCurrentHelpId(44,this.__constructor__.classname);
    </handler>
    
	<!-- ############
		init
	 -->
	<handler name="oninit">
		<![CDATA[
	        //Debug.write("********** this oninit: ",this);
			this.basdrawredoView = new LzView(canvas,{visible:false,y:440});
			this.layers = new Array();
			this.redolayers = new Array();
			this.baseactionobjectList = new Array();
			this.baseredoactionobjectList = new Array();
			this.initheight = this.height;
			this.initwidth = this.width;
			//this.getObjectIdentifier.doCall();
			
		]]>
	</handler>
	
	<method name="clearAll">
		new lz.confirmDeleteWindowCustomLabel(canvas.main_content._content.inner,{refObj:this,
				funcNameConfirm:'clearAllConfirm',messageLabelid:561});
	</method>
	
	<method name="clearAllConfirm" >
		<![CDATA[
			if (this.boundingref!=null) this.boundingref.removeIt();
			while (this.subviews.length > 0) {
				this.subviews[0].destroy();
			}
			while (this.basdrawredoView.subviews.length > 0) {
				this.basdrawredoView.subviews[0].destroy();
			}			
			this.layers = new Array();
			this.redolayers = new Array();
			this.baseactionobjectList = new Array();
			this.baseredoactionobjectList = new Array();	
			this.checkStepLayers();	
			this.onsharedMessage('clear',null);	
            
		]]>
	</method>
	
	<method name="doAction" args="modi">
		if (modi=='saveobj'){
			if (this.sendObject) this.sendObject.sendEvent();
		} else if (modi=='loadobj'){
		
		}
	</method>
	
	<method name="capturePreviousAndSetModus" args="modi">
		this.previousModi = this.drawmodus;
		this.setModus(modi);
		this.setModus(this.previousModi);
	</method>
	
	<method name="setModus" args="modi">
		//check if previous modi has been txt, which might not be saved to the board yet
		//if (this.drawmodus=='letter'){
		//	if (this.letterObjectIsActive){
		//		this.currentletterObj.drawtoArray();
		//	}
		//}
        ////if ($debug) Debug.warn("setModus: ",modi);
        //parent.parent.destroyByMethod = true;
        
		this.setAttribute('drawmodus',modi);
		if (modi=='plain'){
			this.clearAll();
		} else if (modi=='hand' || modi=='hand_single' || modi=='letter' || modi=='paint' 
				|| modi=='line' || modi=='uline' || modi=='rectangle' 
				|| modi=='ellipse' || modi=='drawarrow'
				|| modi=='processgroup' || modi=='process' || modi=='activity'
				|| modi=='connector' || modi=='connector_tree' 
				|| modi=='connector_fork' || modi=='connector_flow'  || modi=='connector_free' 
                || modi=='unitPending' || modi=='companyPending' || modi=='departementPending' 
				|| modi=='company' || modi=='departement' || modi=='unit'
				|| modi=='companyFixed' || modi=='departementFixed' || modi=='unitFixed'
				|| modi=='inputflow' || modi=='outputflow'
				|| modi=='processtree' || modi=='issueflow'){
			if (this.drawmodus == 'connector_tree') {
				this.connectorType = 1;//tree
				this.setAttribute('drawmodus','connector');
			} else if (this.drawmodus == 'connector_fork'){
				this.connectorType = 2;//fork
				this.setAttribute('drawmodus','connector');
			} else if (this.drawmodus == 'connector_flow'){
				this.connectorType = 3;//flow
				this.setAttribute('drawmodus','connector');
			} else if (this.drawmodus == 'connector_free') {
				this.connectorType = 4;//free
                this.setAttribute('drawmodus','connector');
			}
			
			if (this.boundingref!=null) this.boundingref.removeIt();
		} else if (modi=='zoom_in'){
            
            //this.doZoomByNumber(this.currentZoom+20);
            
            if (this.currentZoom == 10) {
                this.doZoomByNumber(25,true);
            } else if (this.currentZoom == 25) {
            	this.doZoomByNumber(50,true);
            } else if (this.currentZoom == 50) {
                this.doZoomByNumber(75,true);
            } else if (this.currentZoom == 75) {
                this.doZoomByNumber(100,true);
            } else if (this.currentZoom == 100) {
                this.doZoomByNumber(150,true);
            } else if (this.currentZoom == 150) {
                this.doZoomByNumber(200,true);
            } else if (this.currentZoom == 200) {
                this.doZoomByNumber(250,true);
            }
            
        } else if (modi=='zoom_out'){
        	
            //this.doZoomByNumber(this.currentZoom-20);
            
            if (this.currentZoom == 25) {
                this.doZoomByNumber(10,true);
            } else if (this.currentZoom == 50) {
                this.doZoomByNumber(25,true);
            } else if (this.currentZoom == 75) {
                this.doZoomByNumber(50,true);
            } else if (this.currentZoom == 100) {
                this.doZoomByNumber(75,true);
            } else if (this.currentZoom == 150) {
                this.doZoomByNumber(100,true);
            } else if (this.currentZoom == 200) {
                this.doZoomByNumber(150,true);
            } else if (this.currentZoom == 250) {
                this.doZoomByNumber(200,true);
            }
            
        } else if (modi=='zoom_reset') {
            
            var mcRef = parent.getMCRef();
            
            this.currentZoom = 100;
            //if ($debug) Debug.write("this.currentZoom,currentZoomT ",this.currentZoom);
            
            mcRef._xscale = this.currentZoom;
            mcRef._yscale = this.currentZoom;
            if ($debug) Debug.write("mcRef 2 W,h",mcRef._width,mcRef._height);
            
            parent.parent.setAttribute('x',0);
            parent.parent.setAttribute('y',0);

            //store value to user-Profile
            canvas.currentDiagramRef._diagramSideBar.updateSidebar();
            
            canvas.currentDiagramRef.zoombar._zoombox.updateZoom(this.currentZoom);
            
        }
		
	</method>
	
	<method name="doZoomByNumber" args="newZoom,doUpdate">
		<![CDATA[
		  
            var deltaZoom = this.currentZoom-newZoom;
            
		    var mcRef = parent.getMCRef();
            
            this.currentZoom = newZoom;
            if ($debug) Debug.write("zoom_in this.currentZoom ",this.currentZoom,deltaZoom);
            
            mcRef._xscale = this.currentZoom;
            mcRef._yscale = this.currentZoom;
            //if ($debug) Debug.write("mcRef 2 W,h",mcRef._width,mcRef._height);
            //parent.setAttribute('width',mcRef._width);
            //parent.setAttribute('height',mcRef._height);
            var newx = parent.parent.x - (parent.parent.width / 100) * Math.round((Math.abs(deltaZoom)/2));
            var newy = parent.parent.y - (parent.parent.height / 100) * Math.round((Math.abs(deltaZoom)/2));
            
            if ($debug) Debug.write("newx,newy",newx,newy,parent.parent.width,parent.parent.height);
            
            if (deltaZoom < 0) {
                parent.parent.setAttribute('x',parent.parent.x - (parent.parent.width / 100) * Math.round((Math.abs(deltaZoom)/2)));
                parent.parent.setAttribute('y',parent.parent.y - (parent.parent.height / 100) * Math.round((Math.abs(deltaZoom)/2)));
            } else {
                parent.parent.setAttribute('x',parent.parent.x + (parent.parent.width / 100) * Math.round((Math.abs(deltaZoom)/2)));
                parent.parent.setAttribute('y',parent.parent.y + (parent.parent.height / 100) * Math.round((Math.abs(deltaZoom)/2)));
            }
            //store value to user-Profile
            canvas.currentDiagramRef._diagramSideBar.updateSidebar();
            
            if (doUpdate) {
            	canvas.currentDiagramRef.zoombar._zoombox.updateZoom(this.currentZoom);
            }
		
		]]>
	</method>
	
	<!--
    	if (this.diagramType != 4) {
            parent.setAttribute('x',-(canvas.defaultDiagramWidth/2-600));
            parent.setAttribute('y',-(canvas.defaultDiagramHeight/2-260));
        } else {
            parent.setAttribute('x',-(canvas.defaultDiagramWidth/2-(canvas.width/2)-100));
            parent.setAttribute('y',-(canvas.defaultDiagramHeight/2-((canvas.height-canvas.naviHeight)/2))+100);
        }
     -->
    <method name="doPrintJob">
        var my_pj:PrintJob = new PrintJob();
        //if($debug) Debug.write("my_pj: ",my_pj);
        //my_pj.addPage(canvas.currentDiagramRef);
        //if($debug) Debug.write("my_pj: ",my_pj);
        if (my_pj.start()) {
            
            var printArea = new Array();
            printArea["xMin"] = 0;
            printArea["xMax"] = 2400;
            printArea["yMin"] = 0;
            printArea["yMax"] = 1600;

            if (my_pj.addPage(this.getMCRef(),{xMin:0,xMax:2400,yMin:0,yMax:1600})) {
                //if($debug) Debug.write("this.getMCRef(): ",this.getMCRef());
                //if($debug) Debug.write("my_pj: ",my_pj);
                my_pj.send();
            }
        }
    </method>
    
    <method name="dev_doPrintJob">
        _root.print(this.getMCRef(), "bframe");
    </method>
	
	<method name="getModusItems" args="modi">
		<![CDATA[
		//Debug.write("getModusItems: ",modi,this.baseactionobjectList);
		if (modi=='pointer'){
			return this.baseactionobjectList;
		} else {
			var tempList = new Array();
			//Debug.write("this.baseactionobjectList: ",modi);
			for (var eg=0;eg<this.baseactionobjectList.length;eg++){
				//Debug.write("this.baseactionobjectList[eg][0]==modi",this.baseactionobjectList[eg][0],modi);
				if (this.baseactionobjectList[eg][0]==modi) {
					tempList.push(this.baseactionobjectList[eg]);
				}
			}		
			return tempList;
		}
		]]>
	</method>
	
	<method name="getObjectByName" args="objName">
		//for (var eg in this.subviews) {
		//	//if ($debug) Debug.write("getObjectByName",this.subviews[eg],"SEARCH: ",objName);
		//}
		//if ($debug) Debug.write("getObjectByName1: ",this,objName);
		//if ($debug) Debug.write("getObjectByName2: ",this[objName]);
		//if ($debug) Debug.write("getObjectByName3: ",this.searchSubviews('name',objName));
		return this[objName];
		//return this.searchSubviews('name',objName);
	</method>
    
    <method name="getBaseObjectListItemByName" args="newName">
        <![CDATA[
            ////if ($debug) Debug.write("updateBaseObjectListItemByName: ",newName,diagramobjectid);
            var item = null;
            for (var i=0;i<this.baseactionobjectList.length;i++) {
                if (this.baseactionobjectList[i][this.baseactionobjectList[i].length-1] == newName){
                    ////if ($debug) Debug.write("Found: ",this.baseactionobjectList[i]);
                    item = this.baseactionobjectList[i];
                    break;
                }
            }        
            
            return item;
        ]]>        
    </method>  
    
    <method name="getBaseObjectListItemsByDiagramId" args="diagramObjectId">
        <![CDATA[
            ////if ($debug) Debug.write("updateBaseObjectListItemByName: ",newName,diagramobjectid);
            var returnList = new Array();
            //var item = null;
            for (var i=0;i<this.baseactionobjectList.length;i++) {
                if (this.baseactionobjectList[i][this.baseactionobjectList[i].length-7] == diagramObjectId){
                    ////if ($debug) Debug.write("Found: ",this.baseactionobjectList[i]);
                    returnList.push(this.baseactionobjectList[i]);
                    //break;
                }
            }        
            
            return returnList;
        ]]>        
    </method>    
	
	<method name="deleteItemByItemList" args="objList">
		<![CDATA[
			for (var i=0;i<objList.length;i++){
				this.deleteItemByName(objList[i].name)
			}
		]]>
	</method>
	
	<method name="deleteItemByName" args="objName">
	<![CDATA[
        //In this List all Objects are collected that should be deleted after or in relation to the object
	    var deleteReferencedObjects = new Array();
	
		this[objName].destroy();
		if (this.boundingref!=null) this.boundingref.removeIt();
		var pos = -1;
		for (var eg=0;eg<this.layers.length;eg++){
			if (this.layers[eg]['name']==objName) {
				pos = eg;
				//Debug.write("Found Object in Layer: ",eg);
				this.layers[eg].destroy();
			}
		}	
		if (pos!=-1) this.layers.splice(pos, 1);
		//get Item Position
		pos = -1;
		for (var eg=0;eg<this.baseactionobjectList.length;eg++){
			if (this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-1]==objName) {
				pos = eg;
				
				if (this.baseactionobjectList[eg][0] == "connectorText") {
                    //if ($debug) Debug.write("Delete Connector Text ",this.baseactionobjectList[eg]);
                    //This means we need to clear the reference in the Connector
                    this.updateConnectorTextObj(this.baseactionobjectList[eg][6],null); 
                } else if (this.baseactionobjectList[eg][0] == "connector") {
                    //if ($debug) Debug.write("DELETE Connector");
                    if (this.baseactionobjectList[eg][9] != null) {
                    	//This means we need to clear all connectorText Objects
                    	//if ($debug) Debug.write("DELETE Connector'S Text Obj ",this.baseactionobjectList[eg][9].name);
                    	deleteReferencedObjects.push(this.baseactionobjectList[eg][9].name);
                    }
			    }
                    
				break;
				//Debug.write("Found Object: ",eg);
			}
		}
		var newA = this.baseactionobjectList[pos];
		if (newA[0]=='paint') newA[1] = new Array();
		this.onsharedMessage('delete',newA);	
		if (pos!=-1) this.baseactionobjectList.splice(pos, 1);
		//Debug.write("this.baseactionobjectList.length: ",this.baseactionobjectList.length);
		//Debug.write("this.layers.length: ",this.layers.length);
		this.checkForUselessConnectors(objName);
		this.checkStepLayers();
		
		if (deleteReferencedObjects.length != 0) {
			for (var i=0;i<deleteReferencedObjects.length;i++) {
			    //if ($debug) Debug.write("DELETE REFERENCE: ",deleteReferencedObjects[i]);
			    this.deleteItemByName(deleteReferencedObjects[i]);
			}
		}
	]]>
	</method>
	
	<method name="updateByObjectConnectors" args="baseObject">
		 <![CDATA[
            ////if ($debug) Debug.write("UpdateByObject : ",objRef,objRef.name);
        
            for (var eg=0;eg<this.baseactionobjectList.length;eg++){
                if (this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-1]==baseObject[baseObject.length-1]) {
                    //if ($debug) Debug.write("Found Object: ",this.baseactionobjectList[eg]);
                    this.baseactionobjectList[eg] = baseObject;
                    break;
                }
            }   
            
        ]]>
    </method>
	
	<method name="UpdateByObject" args="objRef">
		<![CDATA[
            ////if ($debug) Debug.write("UpdateByObject : ",objRef,objRef.name);
		    var objName = objRef.name;
		//for (var eg=0;eg<this.layers.length;eg++){
		//	if (this.layers[eg]['name']==objName) {
		//		//Debug.write("Found Object in Layer: ",this.layers[eg]);
		//	}
		//}
    		for (var eg=0;eg<this.baseactionobjectList.length;eg++){
    			if (this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-1]==objName) {
    				//if ($debug) Debug.write("Found Object: ",this.baseactionobjectList[eg]);
    				this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-5] = objRef.x;
    				this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-4] = objRef.y;
    				this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-3] = objRef.width;
    				this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-2] = objRef.height;
    				//if ($debug) Debug.write("Update Object: ",this.baseactionobjectList[eg]);
    				var newA = this.baseactionobjectList[eg];
    				if (newA[0]=='paint') newA[1] = new Array();				
    				this.onsharedMessage('size',newA);	
    			    break;
    			}
    		}	
			
		]]>
	</method>
	
	<method name="UpdateByObjectList" args="objRefList">
		<![CDATA[
			for (var i=0;i<objRefList.length;i++) {
				this.UpdateByObject(objRefList[i]);
			}
		]]>
	</method>
	
	
	<!-- ##############
		undo/redo
	 -->
	<method name="doredo">
		//Debug.write("redo");
		<![CDATA[
		if (this.redolayers.length>0){
			if (this.boundingref!=null) this.boundingref.removeIt();
			var lastelement = this.redolayers.pop();
			var lastActionObject = this.baseredoactionobjectList.pop();
			//Debug.write(lastActionObject);
			//Redraw the View on the paintarea
			if (lastActionObject[0]=='paint'){
				this.paintactionHistory(lastActionObject,this);lineactionHistory
			} else if (lastActionObject[0]=='line'){
				this.lineactionHistory(lastActionObject,this);
			} else if (lastActionObject[0]=='uline'){
				this.ulineactionHistory(lastActionObject,this);
			} else if (lastActionObject[0]=='drawarrow'){
				this.drawarrowlineactionHistory(lastActionObject,this);
			} else if(lastActionObject[0]=='letter'){
				this.drawactionHistory(lastActionObject,this);
			} else if(lastActionObject[0]=='image'){
				this.addImageToLayerHistory(lastActionObject,this,false);
			} else if(lastActionObject[0]=='swf'){
				this.addSWFToLayerHistory(lastActionObject,this,false);
			} else if(lastActionObject[0]=='rectangle'){
				this.drawrectangleToHistory(lastActionObject,this);
			} else if(lastActionObject[0]=='ellipse'){
				this.drawellipseToHistory(lastActionObject,this);
			}
			//Push to redolayers,ObjectList
			this.layers.push(this.currentlayer);
			this.baseactionobjectList.push(lastActionObject);
			//Remove this View
			lastelement.destroy();
			this.checkStepLayers();
			this.onsharedMessage('redo',lastActionObject);
		}
		]]>
	</method>
	
	<method name="undoredo">
		<![CDATA[
		if (this.layers.length>0){
			if (this.boundingref!=null) this.boundingref.removeIt();
			var lastelement = this.layers.pop();
			var lastActionObject = this.baseactionobjectList.pop();
			//Debug.write(lastActionObject);
			//Redraw the View on the Invisible paintarea
			if (lastActionObject[0]=='paint'){
				//Debug.write("Undo Paint: ",lastActionObject);
				this.paintactionHistory(lastActionObject,this.basdrawredoView);
			} else if (lastActionObject[0]=='line'){
				this.lineactionHistory(lastActionObject,this.basdrawredoView);
			} else if (lastActionObject[0]=='uline'){
				this.ulineactionHistory(lastActionObject,this.basdrawredoView);
			} else if (lastActionObject[0]=='drawarrow'){
				this.drawarrowlineactionHistory(lastActionObject,this.basdrawredoView);
			} else if(lastActionObject[0]=='letter'){
				this.drawactionHistory(lastActionObject,this.basdrawredoView);
			} else if(lastActionObject[0]=='image'){
				this.addImageToLayerHistory(lastActionObject,this.basdrawredoView,false);
			} else if(lastActionObject[0]=='swf'){
				this.addSWFToLayerHistory(lastActionObject,this.basdrawredoView,false);
			} else if(lastActionObject[0]=='rectangle'){
				this.drawrectangleToHistory(lastActionObject,this.basdrawredoView);
			} else if(lastActionObject[0]=='ellipse'){
				this.drawellipseToHistory(lastActionObject,this.basdrawredoView);
			}
			//Push to redolayers,redoObjectList
			this.redolayers.push(this.currentlayer);
			this.baseredoactionobjectList.push(lastActionObject);
			//Remove this View
			lastelement.destroy();
			this.checkStepLayers();		
			this.onsharedMessage('undo',lastActionObject);
		}
		]]>
	</method>

	
	<method name="checkStepLayers">
		if (this.layers.length==0){
			this.setAttribute('hasprevious',false);
		} else {
			this.setAttribute('hasprevious',true);
		}
		if (this.redolayers.length==0){
			this.setAttribute('hasenext',false);
		} else {
			this.setAttribute('hasenext',true);
		}	
		//this.setAttribute('drawmodus',this.getAttribute('drawmodus'));				
	</method>
	
	<method name="onmousedownMethod" >
		<![CDATA[
            //if ($debug)Debug.write("onmousedown: ",this.drawmodus);
            if ($debug) Debug.write("### onmousedown lz.Keys.downKeysArray: ",lz.Keys.downKeysArray);
            
				// ,canvas.defaultOptionmenuKeyNumber
			//Free the item for sure
			this.dragRoot = false;
			lz.Cursor.unlock();
			this.parent.parent.dragger.remove();
			
            this.startedDrawingProcess = true;
            if (lz.Keys.downKeysArray.length == 1) {
            	this.dragRoot = true;
            	lz.Cursor.setCursorGlobal('arrow_cursor_rsc');
            	this.parent.parent.dragger.apply();
            } else if (lz.Keys.downKeysArray.length == 1
				&& lz.Keys.downKeysArray[0] == canvas.defaultOptionmenuKeyNumber ) { 
				//if ($debug) Debug.write("Is Option Menu 1");
				this.isOptionMenu = true;
			} else if (this.drawmodus=="hand_single"){
				var itemListLength = this.doSetHandModus();
                //if ($debug) Debug.write("itemListLength: ",itemListLength);
                if (itemListLength == 0){
                    this.drawmodus = "hand";
                    this.startDrawSelectionBox();
	                this.startx = this.getMouse('x');
	                this.starty = this.getMouse('y');   
	                mousetracker_del.register(lz.Idle,'onidle');
                }
			} else if(this.drawmodus=="hand"){
				//if (this.doSetHandBodus()==0){
				this.startDrawSelectionBox();
				this.startx = this.getMouse('x');
				this.starty = this.getMouse('y'); 	
				mousetracker_del.register(lz.Idle,'onidle');
				//}
			} else if(this.drawmodus=="paint"){
				this.startPaint();
				mousetracker_del.register(lz.Idle,'onidle');
			} else if(this.drawmodus=="line"){
				this.startLine();
	  	 		this.startx = currentlayer.getMouse('x');
				this.starty = currentlayer.getMouse('y'); 			
				mousetracker_del.register(lz.Idle,'onidle');
			} else if(this.drawmodus=="uline"){
				this.startUline();
	  	 		this.startx = currentlayer.getMouse('x');
				this.starty = currentlayer.getMouse('y'); 			
				mousetracker_del.register(lz.Idle,'onidle');
			} else if(this.drawmodus=="drawarrow"){
				this.startDrawarrowline();
	  	 		this.startx = currentlayer.getMouse('x');
				this.starty = currentlayer.getMouse('y'); 			
				mousetracker_del.register(lz.Idle,'onidle');
			} else if (this.drawmodus == 'rectangle') {
				this.startRect();
	  	 		this.startx = currentlayer.getMouse('x');
				this.starty = currentlayer.getMouse('y'); 				
	            mousetracker_del.register(lz.Idle,'onidle');
	        } else if (this.drawmodus == 'ellipse') {
				this.startEllipse();
	  	 		this.startx = currentlayer.getMouse('x');
				this.starty = currentlayer.getMouse('y'); 				
	            mousetracker_del.register(lz.Idle,'onidle');
	        } else if (this.drawmodus == 'processgroup') {
	        	//this.startProcessgroup();
	  	 		this.startx = this.getMouse('x');
				this.starty = this.getMouse('y'); 
				this.drawFixedProcessgroup();
				//mousetracker_del.register(lz.Idle,'onidle');
	        } else if (this.drawmodus == 'process') {
	        	this.startProcess();
	  	 		this.startx = currentlayer.getMouse('x');
				this.starty = currentlayer.getMouse('y'); 
				mousetracker_del.register(lz.Idle,'onidle');
	        } else if (this.drawmodus == 'activity') {
	        	this.startActivity();
	  	 		this.startx = currentlayer.getMouse('x');
				this.starty = currentlayer.getMouse('y'); 
				mousetracker_del.register(lz.Idle,'onidle');
	        } else if (this.drawmodus == 'company') {
                this.startCompany();
                this.startx = currentlayer.getMouse('x');
                this.starty = currentlayer.getMouse('y'); 
                mousetracker_del.register(lz.Idle,'onidle');
            } else if (this.drawmodus == 'companyPending') {
                this.startCompany();
                this.startx = currentlayer.getMouse('x');
                this.starty = currentlayer.getMouse('y'); 
                mousetracker_del.register(lz.Idle,'onidle');
            } else if (this.drawmodus == 'departement') {
                this.startDepartement();
                this.startx = currentlayer.getMouse('x');
                this.starty = currentlayer.getMouse('y'); 
                mousetracker_del.register(lz.Idle,'onidle');
            } else if (this.drawmodus == 'departementPending') {
                this.startDepartement();
                this.startx = currentlayer.getMouse('x');
                this.starty = currentlayer.getMouse('y'); 
                mousetracker_del.register(lz.Idle,'onidle');
            } else if (this.drawmodus == 'unit') {
                this.startUnit();
                this.startx = currentlayer.getMouse('x');
                this.starty = currentlayer.getMouse('y'); 
                mousetracker_del.register(lz.Idle,'onidle');
            } else if (this.drawmodus == 'unitPending') {
                //Same as Pending
                this.startUnit();
                this.startx = currentlayer.getMouse('x');
                this.starty = currentlayer.getMouse('y'); 
                mousetracker_del.register(lz.Idle,'onidle');
            } else if (this.drawmodus == 'inputflow') {
	        	this.startInputflow();
	  	 		this.startx = currentlayer.getMouse('x');
				this.starty = currentlayer.getMouse('y'); 
				mousetracker_del.register(lz.Idle,'onidle');
	        } else if (this.drawmodus == 'outputflow') {
	        	this.startOutputflow();
	  	 		this.startx = currentlayer.getMouse('x');
				this.starty = currentlayer.getMouse('y'); 
				mousetracker_del.register(lz.Idle,'onidle');
	        } else if (this.drawmodus == 'issueflow') {
	        	this.startIssueflow();
	  	 		this.startx = currentlayer.getMouse('x');
				this.starty = currentlayer.getMouse('y'); 
				mousetracker_del.register(lz.Idle,'onidle');
	        } else if (this.drawmodus == 'processtree') {
	        	//this.startOutputflow();
	  	 		this.startx = this.getMouse('x');
				this.starty = this.getMouse('y'); 
				this.drawFixedProcess();
				//mousetracker_del.register(lz.Idle,'onidle');
	        } else if (this.drawmodus == 'companyFixed') {
	        	//this.startOutputflow();
	  	 		this.startx = this.getMouse('x');
				this.starty = this.getMouse('y'); 
				this.drawFixedCompany();
				//mousetracker_del.register(lz.Idle,'onidle');
	        } else if (this.drawmodus == 'departementFixed') {
	        	//this.startOutputflow();
	  	 		this.startx = this.getMouse('x');
				this.starty = this.getMouse('y'); 
				this.drawFixedDepartement();
				//mousetracker_del.register(lz.Idle,'onidle');
	        } else if (this.drawmodus == 'unitFixed') {
	        	//this.startOutputflow();
	  	 		this.startx = this.getMouse('x');
				this.starty = this.getMouse('y'); 
				this.drawFixedUnit();
				//mousetracker_del.register(lz.Idle,'onidle');
		    } else if (this.drawmodus == 'letter') {
                this.startLetter();
                this.startx = currentlayer.getMouse('x');
                this.starty = currentlayer.getMouse('y');               
                mousetracker_del.register(lz.Idle,'onidle');
            } else if (this.drawmodus == 'departement') {
                this.startDepartement();
                this.startx = currentlayer.getMouse('x');
                this.starty = currentlayer.getMouse('y');               
                mousetracker_del.register(lz.Idle,'onidle');
            } else if (this.drawmodus == 'departement') {
                this.startCompany();
                this.startx = currentlayer.getMouse('x');
                this.starty = currentlayer.getMouse('y');               
                mousetracker_del.register(lz.Idle,'onidle');
            } else if (this.drawmodus == "connector") {
            	this.startObjConnector();
            }
        ]]>
	</method>

	<method name="onmouseupMethod" >
        //if ($debug) Debug.write("### onmouseup this.drawmodus: ",this.drawmodus);
		<![CDATA[	
		
		//if (this.letterObjectIsActive){
			//this.currentletterObj.drawtoArray();
			//bool = true;
		//}	
		
		//if ($debug) Debug.write("### onmouseup this.drawmodus: ",this.drawmodus,this.boundingIsActive);
		
		if (this.dragRoot) {
			this.dragRoot = false;
			lz.Cursor.unlock();
			this.parent.parent.dragger.remove();
		} else if (this.isOptionMenu) {
			this.isOptionMenu = false;
			//if ($debug) Debug.write("Is Option Menu 2");
			var item = this.getUpMostObject();
			if (item!=null) {
				//if ($debug) Debug.write("Found Item For Right Click: ",item);
				var rightClick = new lz.rightClickMenu(canvas,{x:canvas.getMouse('x'),y:canvas.getMouse('y'),
									itemRef:item,whiteBoardRef:this});
				lz.ModeManager.makeModal( rightClick );
			}
		} else if (this.drawmodus=="hand_single"){
			if (this.boundingIsActive){
				if (this.boundingref.isDragable) {
					//Type connector has no _innerDrag active to drag
				    this.boundingref._innerDrag.onmouseup.sendEvent();
				}
				//See connector tool
                this.onMouseUpInHandModusAndActiveBox();
			}
		} else if (this.drawmodus=="hand"){
			this.endDrawSelectionBox();
			mousetracker_del.unregisterAll();
			if (Math.abs(this.startx-this.endx) < 10 && 
				Math.abs(this.starty-this.endy) < 10){
				this.doSetHandBodus();
			} else {				
				this.calcCurrentObjectMultiSelection();
			}
            this.drawmodus = "hand_single";
		} else if(this.drawmodus=="paint"){
			this.endPaint();
			mousetracker_del.unregisterAll();
		} else if(this.drawmodus=="line"){
			this.endLine();
			mousetracker_del.unregisterAll();
		} else if(this.drawmodus=="drawarrow"){
			this.endDrawarrowline();
			mousetracker_del.unregisterAll();
		} else if(this.drawmodus=="uline"){
			this.endUline();
			mousetracker_del.unregisterAll();
		} else if(this.drawmodus=="letter"){
			//if (!this.letterObjectIsActive && !bool){
			//	this.currentletterObj = new lz.baseDrawWords(canvas,{refObj:this,x:canvas.getMouse('x'),y:canvas.getMouse('y')});
			//}
			this.endLetter();
			mousetracker_del.unregisterAll();
		} else if (this.drawmodus == 'rectangle') {
			this.endRect();
        	mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'ellipse') {
			this.endEllipse();
        	mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'pointer') {
        	this.setAttribute('drawmodus','hand');
        	//if ($debug) Debug.write("onmouse")
			if (this.boundingIsActive){
				if (this.boundingref.isDragable) {
				    this.boundingref._innerDrag.onmouseup.sendEvent();
				}
			}
        } else if (this.drawmodus == 'processgroup') {
			//this.endProcessgroup();
        	//mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'process') {
			this.endProcess();
        	mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'activity') {
			this.endActivity();
        	mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'company') {
            this.endCompany();
            mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'companyPending') {
            this.endCompanyPending();
            mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'departement') {
            this.endDepartement();
            mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'departementPending') {
            this.endDepartementPending();
            mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'company') {
            this.endCompany();
            mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'unit') {
            this.endUnit();
            mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'unitPending') {
            this.endUnitPending();
            mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'inputflow') {
			this.endInputflow();
        	mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'outputflow') {
			this.endOutputflow();
        	mousetracker_del.unregisterAll();
        } else if (this.drawmodus == 'issueflow') {
			this.endIssueflow();
        	mousetracker_del.unregisterAll();
        //} else if (this.drawmodus == 'connector') {
        //    parent.parent.parent._toolBar.doSelectItem("hand_single");
        } else if (this.drawmodus == "connector") {
            this.endObjConnector();
        }
        
        ////Debug.write("onmouseup: ",this.letterObjectIsActive,this.currentletterObj);	        
		this.checkStepLayers();
		this.startedDrawingProcess = false;
		]]>
	</method>  
	
	<!--
        Remove all objects from drawing et cetera
	 -->
	<method name="clearCurrentClickAction">
		<![CDATA[
            canvas.currentDragObject.close();
            //Stop Drawing Process
            if (this.startedDrawingProcess) {
            	mousetracker_del.unregisterAll();
            	this.currentlayer.destroy();
            }
		]]>
	</method>
	
    <!--
    <handler name="onclick" args="obj">
        //Debug.write("click on whiteBoard ",obj);
    </handler>
     -->

  	<method name="trackmouse" args="item" >
    	<![CDATA[

    	this.mx = currentlayer.getMouse('x');
    	this.my = currentlayer.getMouse('y');   

    	////if ($debug) Debug.write("this.drawmodus: ",this.drawmodus);
    	
    	if (this.drawmodus=="paint"){	    	
		    if (mx != prevx || my != prevy) {
		        if (prevx == null) {
		            prevx = mx;
		        }
		        if (prevy == null) {
		            prevy = my;
		        }
	            var mmx = this.mx;
	            var mmy = this.my;
	            var px = this.prevx;
	            var py = this.prevy;

	            this.drawline(px, py, mmx, mmy);
	            this.drawlineRegisterPaint(px, py, mmx, mmy);
	            
	            this.prevx  = this.mx;
	            this.prevy = this.my;            
	        } 
	    } else if (this.drawmodus=="line"){	 
	    	this.currentlayer.destroy();
	    	this.startLine();
			this.endx = this.mx;
			this.endy = this.my;
            this.drawline(this.startx, this.starty, this.endx, this.endy);
	    } else if (this.drawmodus=="hand"){	 
	    	this.currentlayer.destroy();
	    	this.startDrawSelectionBox();
			this.endx = this.mx;
			this.endy = this.my;
            this.drawSelectionBox(this.startx, this.starty, this.endx, this.endy);
	    } else if (this.drawmodus=="uline"){
	    	this.currentlayer.destroy();
	    	this.startUline();
			this.endx = this.mx;
			this.endy = this.my;
            this.drawline(this.startx, this.starty, this.endx, this.endy);
	    } else if (this.drawmodus=="drawarrow"){	
	    	//Debug.write(" this.currentlayer.destroy ");
	    	this.currentlayer.destroy();
	    	this.startDrawarrowline();
			this.endx = this.mx;
			this.endy = this.my;
	    } else if (this.drawmodus == 'rectangle') {
	    	this.currentlayer.destroy();
	    	this.startRect();
			// stretchy rect mode
			this.endx = this.mx;
			this.endy = this.my;
			this.drawrectangle (this.startx, this.starty, this.mx, this.my);
		} else if (this.drawmodus == 'ellipse') {
	    	this.currentlayer.destroy();
	    	this.startEllipse();
			// stretchy rect mode
			this.endx = this.mx;
			this.endy = this.my;
			this.drawellipse (this.startx, this.starty, this.mx, this.my);			
		} else if (this.drawmodus == 'processgroup') {
	    	this.currentlayer.destroy();
	    	this.startProcessgroup();
			// stretchy rect mode
			this.endx = this.mx;
			this.endy = this.my;
			this.drawProcessgroup (this.startx, this.starty, this.mx, this.my);			
		} else if (this.drawmodus == 'process') {
	    	this.currentlayer.destroy();
	    	this.startProcess();
			// stretchy rect mode
			this.endx = this.mx;
			this.endy = this.my;
			this.drawProcess (this.startx, this.starty, this.mx, this.my);			
		} else if (this.drawmodus == 'activity') {
	    	this.currentlayer.destroy();
	    	this.startActivity();
			// stretchy rect mode
			this.endx = this.mx;
			this.endy = this.my;
			this.drawActivity (this.startx, this.starty, this.mx, this.my);			
		} else if (this.drawmodus == 'company') {
            this.currentlayer.destroy();
            this.startCompany();
            // stretchy rect mode
            this.endx = this.mx;
            this.endy = this.my;
            this.drawCompany(this.startx, this.starty, this.mx, this.my);           
        } else if (this.drawmodus == 'companyPending') {
            this.currentlayer.destroy();
            this.startCompany();
            // stretchy rect mode
            this.endx = this.mx;
            this.endy = this.my;
            this.drawCompanyPending(this.startx, this.starty, this.mx, this.my);           
        } else if (this.drawmodus == 'departement') {
            this.currentlayer.destroy();
            this.startDepartement();
            // stretchy rect mode
            this.endx = this.mx;
            this.endy = this.my;
            this.drawDepartement(this.startx, this.starty, this.mx, this.my);           
        } else if (this.drawmodus == 'departementPending') {
            this.currentlayer.destroy();
            this.startDepartement();
            // stretchy rect mode
            this.endx = this.mx;
            this.endy = this.my;
            this.drawDepartementPending(this.startx, this.starty, this.mx, this.my);           
        } else if (this.drawmodus == 'unit') {
            this.currentlayer.destroy();
            this.startUnit();
            // stretchy rect mode
            this.endx = this.mx;
            this.endy = this.my;
            this.drawUnit (this.startx, this.starty, this.mx, this.my);         
        } else if (this.drawmodus == 'unitPending') {
            this.currentlayer.destroy();
            //Same as Pending
            this.startUnit();
            // stretchy rect mode
            this.endx = this.mx;
            this.endy = this.my;
            this.drawUnitPending(this.startx, this.starty, this.mx, this.my);         
        } else if (this.drawmodus == 'inputflow') {
	    	this.currentlayer.destroy();
	    	this.startInputflow();
			// stretchy rect mode
			this.endx = this.mx;
			this.endy = this.my;
			this.drawInputflow (this.startx, this.starty, this.mx, this.my);			
		} else if (this.drawmodus == 'outputflow') {
	    	this.currentlayer.destroy();
	    	this.startOutputflow();
			// stretchy rect mode
			this.endx = this.mx;
			this.endy = this.my;
			this.drawOutputflow (this.startx, this.starty, this.mx, this.my);			
		} else if (this.drawmodus == 'issueflow') {
	    	this.currentlayer.destroy();
	    	this.startIssueflow();
			// stretchy rect mode
			this.endx = this.mx;
			this.endy = this.my;
			this.drawIssueflow (this.startx, this.starty, this.mx, this.my);			
		} else if (this.drawmodus == 'letter') {
			var oid_name = this.currentlayer.name;
	    	this.currentlayer.destroy();
	    	this.startLetter(oid_name);
			// stretchy rect mode
			this.endx = this.mx;
			this.endy = this.my;
			this.drawletterBoundingBox (this.startx, this.starty, this.mx, this.my);			
		}	
    	]]>
    </method>
    
   	<method name="checkScreenCanvasPosition" args="objRef,boundingbox">
   		<![CDATA[
		   	
   			var minx = 0;
		   	var maxx = this.initwidth;
		   	
			var miny = 0;
		   	var maxy = this.initheight;
		   	
			for (var i = 0;i<this.subviews.length;i++) {
				var newmaxy = this.subviews[i].y+this.subviews[i].height;
				var newminy = this.subviews[i].y;
				
				var newmaxx = this.subviews[i].x+this.subviews[i].width;
				var newminx = this.subviews[i].x;
				
				if (newmaxy > maxy) {
					maxy = newmaxy;
				}
				if (newminy < miny) {
					miny =  newminy;
				}
				
				if (newmaxx > maxx) {
					maxx = newmaxx;
				}
				if (newminx < minx) {
					minx =  newminx;
				}
			}
			var scrollheight = maxy - miny;
			var scrollwidth = maxx - minx;
			////if ($debug) Debug.write("miny,maxy,p: ",scrollheight,miny,maxy,-parent.y);
			canvas._scrollcontent._content.setAttribute('height',scrollheight);
			canvas._scrollcontent._content.setAttribute('y',miny+parent.y);
			
			////if ($debug) Debug.write("minx,maxx,p: ",scrollwidth,minx,maxx,parent.x);
			canvas._scrollcontent._content.setAttribute('width',scrollwidth);
			canvas._scrollcontent._content.setAttribute('x',minx+parent.x);
   			
   		]]>
   	</method>
   	
   	<!--

   	 -->
	
	<!-- ####################
		Handmodus
	 -->
	
	<method name="doSetHandModus_bb" >
		////if ($debug) Debug.write("doSetHandBodus: ");
		var objList = this.getObjectInBounds(this.getMouse('x'),this.getMouse('y'));
		////if ($debug) Debug.write("doSetHandModus objList ",objList);
	</method>
	
	<method name="doSetHandModus" >
		<![CDATA[
			////if ($debug) Debug.write("doSetHandModus: ");
			var objList = this.getObjectInBounds(this.getMouse('x'),this.getMouse('y'));
            ////if ($debug) Debug.write("doSetHandModus: ",objList.length);
			if(objList.length==1){
				var newName = objList[0][objList[0].length-1];
				this.setAttribute("currentSelectedObjectName",newName);
				//this.parent._drawareaobjectcombobox.preselectedName=objList[0][objList[0].length-1];
				//this.setAttribute('drawmodus','pointer');
				////if ($debug) Debug.write("-a-",objList[0][objList[0].length-1]);
				this.doShowObjectBounds(newName,objList[objList.length-1],true);
			} else if (objList.length>1){
				var newName = objList[objList.length-1][objList[objList.length-1].length-1];
				this.setAttribute("currentSelectedObjectName",newName);
				//this.parent._drawareaobjectcombobox.preselectedName=objList[objList.length-1][objList[objList.length-1].length-1];
				//this.setAttribute('drawmodus','pointer');
				////if ($debug) Debug.write("-b-",objList[objList.length-1][objList[objList.length-1].length-1]);
				this.doShowObjectBounds(newName,objList[objList.length-1],true);
				//new chooseDrawAreaObjectWindow(canvas,{x:300,y:200,refObj:this,listV:objList});
			} else {
				if (this.boundingref!=null)this.boundingref.removeIt();
			}
			return objList.length;
		]]>
	</method>	 
	 
	<method name="doSetHandBodus" >
		<![CDATA[
			//if ($debug) Debug.write("doSetHandBodus: ");
			var objList = this.getObjectInBounds(this.getMouse('x'),this.getMouse('y'));
            ////if ($debug) Debug.write("doSetHandBodus: ",objList.length,objList);
			if(objList.length==1){
				//this.parent._drawareaobjectcombobox.preselectedName=objList[0][objList[0].length-1];
				//this.setAttribute('drawmodus','pointer');
				////if ($debug) Debug.write("-1-",objList[0][objList[0].length-1]);
				this.doShowObjectBounds(objList[0][objList[0].length-1],objList[objList.length-1],false);
			} else if (objList.length>1){
				//this.parent._drawareaobjectcombobox.preselectedName=objList[objList.length-1][objList[objList.length-1].length-1];
				//this.setAttribute('drawmodus','pointer');
				////if ($debug) Debug.write("-2-",objList[objList.length-1][objList[objList.length-1].length-1]);
				this.doShowObjectBounds(objList[objList.length-1][objList[objList.length-1].length-1],objList[objList.length-1],false);
				//new chooseDrawAreaObjectWindow(canvas,{x:300,y:200,refObj:this,listV:objList});
			} else {
				if (this.boundingref!=null)this.boundingref.removeIt();
			}
			return objList.length;
		]]>
	</method>
	
	<method name="doSetHandModusByObject" args="objRef,boundingRef" >
		<![CDATA[
			////if ($debug) Debug.write("doSetHandBodus: ");
			var objList = this.getObjectInBounds(this.getMouse('x'),this.getMouse('y'));
			if(objList.length==1){
				////if ($debug) Debug.write("Found only self 1");
				return null;
			} else if (objList.length>1){
				//this.parent._drawareaobjectcombobox.preselectedName=objList[objList.length-1][objList[objList.length-1].length-1];
				//this.setAttribute('drawmodus','pointer');
				var ObjectByName = this.getObjectByName(objList[objList.length-1][objList[objList.length-1].length-1]);
				if(ObjectByName == objRef){
					////if ($debug) Debug.write("Found only self 2",objRef,ObjectByName);
					return null;
				} else {
					////if ($debug) Debug.write("Found different, New selection",ObjectByName,objRef);
					boundingRef.removeIt();
					////if ($debug) Debug.write(objList[objList.length-1][objList[objList.length-1].length-1]);
					this.doShowObjectBounds(objList[objList.length-1][objList[objList.length-1].length-1],objList[objList.length-1],false);
					return ObjectByName;
				}
				//new chooseDrawAreaObjectWindow(canvas,{x:300,y:200,refObj:this,listV:objList});
			}
			return null;
		]]>
	</method>		
	
	<method name="getUpMostObject" >
		<![CDATA[
			//if ($debug) Debug.write("getUpMostObject: ");
			var objList = this.getObjectInBounds(this.getMouse('x'),this.getMouse('y'));
			if(objList.length==1){
				return objList[0];
			} else if (objList.length>1){
				return objList[objList.length-1];
			}
			return null;
		]]>
	</method>
	
    <method name="doShowObjectBounds" args="val,baseObj,doMouseUp">
	    <![CDATA[
	    	if (val !=null && val!=''){
		    	this.ObjectByName = this.getObjectByName(val);
		    	
		    	//if ($debug) Debug.write("doShowObjectBounds ",this.ObjectByName,val);
	               
		    	var x = this.ObjectByName.x;
		    	var y = this.ObjectByName.y;
	            //if ($debug) Debug.write("doShowObjectBounds: ",x,y);
		    	var width = this.ObjectByName.width;
		    	var height = this.ObjectByName.height;
		    	if (this.boundingref!=null)this.boundingref.removeIt();
		    	//If connector Component, show the Objects Bounds
		    	////if ($debug) Debug.write("doShowObjectBounds, ",val,val[0]);
				if (baseObj[0]=="connector"){
					//if ($debug) Debug.write("Found Connector to select ",baseObj);
					this.checkConnectorObjectDrawLine(baseObj,0,0,true);
				}		    	
				
				//Never do throw a direct Update
		    	this.boundingref = new lz.boundingBoxAll(this.parent.boundboxesView,{whiteboardRef:this,
	                    objRef:this.ObjectByName,x:x,y:y,width:width,height:height,
	                    ex:x,ey:y,ewidth:width,eheight:height,boundingDoUpdateOnInit:doMouseUp});
		    	this.setAttribute('boundingIsActive',true);
	             
	    	}
	    ]]>
    </method> 

    <!--
        Method to prevent that the DoubleClick Event does get called
     -->
    <method name="doShowObjectBoundsResetStatus" args="val,baseObj,doMouseUp">
        <![CDATA[
            if (val !=null && val!=''){
            	
            	this.boundingBoxPreStatusReset = false;
            	
                this.ObjectByName = this.getObjectByName(val);
                
                //if ($debug) Debug.write("doShowObjectBounds ",this.ObjectByName,val);
                   
                var x = this.ObjectByName.x;
                var y = this.ObjectByName.y;
                //if ($debug) Debug.write("doShowObjectBounds: ",x,y);
                var width = this.ObjectByName.width;
                var height = this.ObjectByName.height;
                if (this.boundingref!=null)this.boundingref.removeIt();
                
                //If connector Component, show the Objects Bounds
                ////if ($debug) Debug.write("doShowObjectBounds, ",val,val[0]);
                if (baseObj[0]=="connector"){
                    //if ($debug) Debug.write("Found Connector to select ",baseObj);
                    this.checkConnectorObjectDrawLine(baseObj,0,0,true);
                }               
                
                //Never do throw a direct Update
                this.boundingref = new lz.boundingBoxAll(this.parent.boundboxesView,{whiteboardRef:this,
                        objRef:this.ObjectByName,x:x,y:y,width:width,height:height,
                        ex:x,ey:y,ewidth:width,eheight:height,boundingDoUpdateOnInit:doMouseUp});
                this.setAttribute('boundingIsActive',true);
                
                this.boundingBoxPreStatusReset = true;
                 
            }
        ]]>
    </method> 
    <method name="calcCurrentObjectMultiSelection">
    	<![CDATA[
	    	////if ($debug) Debug.write("calcCurrentObjectMultiSelection: ",
	    	//		this.startx,this.starty,this.endx,this.endy);
	    	
	    	var minx,miny,maxx,maxy = 0;
	    	if (this.startx <= this.endx && this.starty <= this.endy){
                ////if ($debug) Debug.write("CASE 1 this.startx <= this.endx && this.starty <= this.endy");
	    		minx = this.startx;
	    		miny = this.starty;
	    		maxx = this.endx;
	    		maxy = this.endy;
	    	} else if (this.startx <= this.endx && this.endy <= this.starty){
                ////if ($debug) Debug.write("CASE 2 this.startx <= this.endx && this.endy <= this.starty");
	    		minx = this.startx;
	    		miny = this.endy;
	    		maxx = this.endx;
	    		maxy = this.starty;
	    	} else if (this.startx >= this.endx && this.starty <= this.endy){
                ////if ($debug) Debug.write("CASE 3 this.startx >= this.endx && this.starty <= this.endy");
	    		minx = this.endx;
	    		miny = this.starty;
	    		maxx = this.startx;
	    		maxy = this.endy;
	    	} else if (this.startx >= this.endx && this.endy <= this.starty){
                ////if ($debug) Debug.write("CASE 4 this.startx >= this.endx && this.endy <= this.starty");
	    		minx = this.endx;
	    		miny = this.endy;
	    		maxx = this.startx;
	    		maxy = this.starty;
	    	}
	    	
	    	var objectList = this.getObjectInBoundsSelectionBox(minx,miny,maxx,maxy);
	    	
	    	//if ($debug) Debug.write("Found objList: ",objectList);
	    	if (objectList!=null) {
	    		if (objectList.length == 1){
	    			this.doShowObjectBounds(objectList[0][objectList[0].length-1],objectList[objectList.length-1],false);
	    		} else if (objectList.length > 1){
	    			//Show multiselection Box
	    			if (this.boundingref!=null)this.boundingref.removeIt();
	    			var objRefList = new Array();
	    			var boundingBoxx1 = maxx;
	    			var boundingBoxy1 = maxy;
	    			var boundingBoxx2 = minx;
	    			var boundingBoxy2 = miny;
	    			
	    			var currentX = objectList[0][objectList[0].length-5];
	    			var currentY = objectList[0][objectList[0].length-4];
	    			for (var eg=0;eg<objectList.length;eg++){
	    				//if ($debug) Debug.write("objectList: ",objectList[eg]);
						var objX = objectList[eg][objectList[eg].length-5];
						var objY = objectList[eg][objectList[eg].length-4];
						var objWidth = objectList[eg][objectList[eg].length-3];
						var objHeight = objectList[eg][objectList[eg].length-2];
						if (objX < boundingBoxx1){
							boundingBoxx1 = objX;
						}
						if (objY < boundingBoxy1){
							boundingBoxy1 = objY;
						}
						if (objX+objWidth > boundingBoxx2){
							boundingBoxx2 = objX+objWidth;
						}
						if (objY+objHeight > boundingBoxy2){
							boundingBoxy2 = objY+objHeight;
						}
						
						////if ($debug) Debug.write("objX,objY,objWidth,objHeight: ",objX,objY,objWidth,objHeight);
						
						if (objX < currentX){
							objRefList.splice(0,0,this.getObjectByName(objectList[eg][objectList[eg].length-1]));
						} else {
							objRefList.push(this.getObjectByName(objectList[eg][objectList[eg].length-1]));
						}
	    			}
	    			
	    			////if ($debug) Debug.write("objRefList: ",objRefList);
	    			
	    			var x = boundingBoxx1;
	    			var y = boundingBoxy1;
	    			var width = boundingBoxx2-boundingBoxx1;
	    			var height = boundingBoxy2-boundingBoxy1;
	    			
	    			////if ($debug) Debug.write("Final x,y,width,height: ",x,y,width,height);
	    			
	    			this.boundingref = new lz.boundingBoxAll(this.parent.boundboxesView,{whiteboardRef:this,
		                    objRef:objRefList,x:x-200,y:y-200,width:width+400,height:height+400,
		                    ex:x,ey:y,ewidth:width,eheight:height,boundingDoUpdateOnInit:false,
		                    multiselect:true});
			    	this.setAttribute('boundingIsActive',true);
			    	
	    		} else {
					if (this.boundingref!=null)this.boundingref.removeIt();
				}
	    	} else {
	    		//if ($debug) Debug.warn("Error in calcCurrentObjectMultiSelection, objectList is null!",objectList);
	    	}
    	]]>
    </method> 
	
	<method name="updateObjectBounds">
		if (this.boundingref!=null) this.boundingref.resetValues();
	</method>
    
	<method name="getObjectInBounds" args="x,y">
		<![CDATA[
			var tempList = new Array();
			////Debug.write("getObjectInBounds this.baseactionobjectList1: ",x,y,this.baseactionobjectList);
			for (var eg=0;eg<this.baseactionobjectList.length;eg++){
                
                var x1 = this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-5] - 5;
                var x2 = ( x1 + this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-3] ) + 10;
                
                var y1 = this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-4] - 5;
                var y2 = ( y1 + this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-2] ) + 10;
                
                ////if ($debug) Debug.write("x,y,||,x1,x2,y1,y2,type: ",x,y,"||",
                //    x1,x2,y1,y2,this.baseactionobjectList[eg][0],
                //    "width,height",this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-3],this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-2]);
                
                //if (this.baseactionobjectList[eg][0]=="connector") {
                //    //if ($debug) Debug.write("RECT: ",x1,y1,"W|H: ",Math.abs(x2-x1),Math.abs(y2-y1));
                //    new LzView(this,{x:x1,y:y1,bgcolor:0xFF3300,
                //            width:Math.abs(x2-x1),height:Math.abs(y2-y1)});
                //}
                
				if ( ((x1 < x) && (x2 >= x)) 
					   && ((y1 < y) && (y2 > y)) ) {
					if (this.baseactionobjectList[eg][0]=="connector"){
						////if ($debug) Debug.write("Found Connector ",this.baseactionobjectList[eg]);
						if (this.checkConnectorObjectDrawLine(this.baseactionobjectList[eg],x,y,false)) {
							tempList.push(this.baseactionobjectList[eg]);
						}
					} else {
						tempList.push(this.baseactionobjectList[eg]);
					}
					////if ($debug) Debug.write("found obj: ",this.baseactionobjectList[eg]);
				}
	
			}		
			return tempList;
		]]>
	</method>
	
	<!--
	   && this.baseactionobjectList[eg][0] != "unit" &&
        this.baseactionobjectList[eg][0] != "company" && 
        this.baseactionobjectList[eg][0] != "departement"
     -->
	<method name="getObjectInBoundsConnectable" args="x,y">
        <![CDATA[
            var tempList = new Array();
            ////Debug.write("getObjectInBounds this.baseactionobjectList1: ",x,y,this.baseactionobjectList);
            
            for (var eg=0;eg<this.baseactionobjectList.length;eg++){
                
            	////if ($debug) Debug.write("tco",this.baseactionobjectList[eg][0]);
            	//typeOfObject:  unit 
                //typeOfObject:  company 
                //typeOfObject:  departement

            	if (this.baseactionobjectList[eg][0] != "connector"){
            		var x1 = this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-5] - 5;
                    var x2 = ( x1 + this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-3] ) + 10;
                    
                    var y1 = this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-4] - 5;
                    var y2 = ( y1 + this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-2] ) + 10;
                    
                    if ( ((x1 < x) && (x2 >= x)) 
                           && ((y1 < y) && (y2 > y)) ) {
                        tempList.push(this.baseactionobjectList[eg]);
                        ////if ($debug) Debug.write("found obj: ",this.baseactionobjectList[eg]);
                    }
            	}
            }       
            return tempList;
        ]]>
    </method>
	
	<method name="getObjectInBoundsSelectionBox" args="x1,y1,x2,y2">
		<![CDATA[
			var tempList = new Array();
			//if ($debug) Debug.write("getObjectInBoundsSelectionBox this.baseactionobjectList1: ",x,y,this.baseactionobjectList);
			for (var eg=0;eg<this.baseactionobjectList.length;eg++){
				if (this.baseactionobjectList[eg][0]!="connector"){
					var objX = this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-5];
					var objY = this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-4];
					var objWidth = this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-3];
					var objHeight = this.baseactionobjectList[eg][this.baseactionobjectList[eg].length-2];
					
					if (objX >= x1 && (objX+objWidth) < x2 
							&& objY >= y1 && (objY+objHeight) <= y2 ){
						tempList.push(this.baseactionobjectList[eg]);
					}
				}
			}		
			return tempList;
		]]>
	</method>	
	
	
	
	
	<!-- ##################
		SharedModus
		action => type of action
		actionObject => necessary information to reproduce the event
		isWmlLoader => true means this object is loaded through a stored wml-file
		so do not spread any update-notifications to connected clients for each 
		object cause the file loading will make a seperate notification
	 -->
	<method name="sendWatchObject" args="action,actionObject,isWmlLoader,addInfos,diagramDocuments">
		if ($debug) Debug.write("sendWatchObject: ",diagramDocuments);
		<![CDATA[
		if (action=='draw' || action=='redo'){
			var lastactionObject = actionObject;
			
			//Redraw the View on the paintarea
			if (actionObject[0]=='paint'){
				this.paintactionHistory(lastactionObject,this);
			} else if (actionObject[0]=='line'){
				this.lineactionHistory(lastactionObject,this);
			} else if (actionObject[0]=='uline'){
				this.ulineactionHistory(lastactionObject,this);
			} else if (actionObject[0]=='drawarrow'){
				this.drawarrowlineactionHistory(lastactionObject,this);
			} else if(action,actionObject[0]=='letter'){
				this.drawactionHistory(lastactionObject,this);
			} else if(actionObject[0]=='image'){
				//Image will send the onwmlLoaderSend later cause it has to be send
				//once the image has been loaded completely
				this.addImageToLayerHistory(lastactionObject,this,isWmlLoader);
			} else if(actionObject[0]=='swf'){
				//Image will send the onwmlLoaderSend later cause it has to be send
				//once the image has been loaded completely
				this.addSWFToLayerHistory(lastactionObject,this,isWmlLoader);
			} else if(actionObject[0]=='rectangle'){
				this.drawrectangleToHistory(lastactionObject,this);
			} else if(actionObject[0]=='ellipse'){
				this.drawellipseToHistory(lastactionObject,this);
			} else if(actionObject[0]=='ellipse'){
				this.drawellipseToHistory(lastactionObject,this);
			} else if (actionObject[0]=='outputflow'){
				this.loadOutputflow(lastactionObject[lastactionObject.length-8],
					lastactionObject[lastactionObject.length-7],
					lastactionObject[lastactionObject.length-5],
					lastactionObject[lastactionObject.length-4],
					lastactionObject[lastactionObject.length-3],
					lastactionObject[lastactionObject.length-2],
					lastactionObject[lastactionObject.length-1],
                    lastactionObject[lastactionObject.length-9],
                    lastactionObject[lastactionObject.length-10],
                    lastactionObject[lastactionObject.length-11]
                    );
			} else if (actionObject[0]=='inputflow'){
				this.loadInputflow(lastactionObject[lastactionObject.length-8],
					lastactionObject[lastactionObject.length-7],
					lastactionObject[lastactionObject.length-5],
					lastactionObject[lastactionObject.length-4],
					lastactionObject[lastactionObject.length-3],
					lastactionObject[lastactionObject.length-2],
					lastactionObject[lastactionObject.length-1],
                    lastactionObject[lastactionObject.length-9],
                    lastactionObject[lastactionObject.length-10],
                    lastactionObject[lastactionObject.length-11]
                    );
			} else if (actionObject[0]=='activity'){
				this.loadActivity(lastactionObject[lastactionObject.length-8],
					lastactionObject[lastactionObject.length-7],
					lastactionObject[lastactionObject.length-5],
					lastactionObject[lastactionObject.length-4],
					lastactionObject[lastactionObject.length-3],
					lastactionObject[lastactionObject.length-2],
					lastactionObject[lastactionObject.length-1],
                    lastactionObject[lastactionObject.length-9],
                    lastactionObject[lastactionObject.length-10],
                    lastactionObject[lastactionObject.length-11]
                    );
			} else if (actionObject[0]=='process'){
                if ($debug) Debug.warn("ALERT THIS CANNOT HAPPEN: basedraw Line 1467 actionObject[0]==process");
				//this.loadProcess(lastactionObject[lastactionObject.length-8],
				//	lastactionObject[lastactionObject.length-7],
				//	lastactionObject[lastactionObject.length-5],
				//	lastactionObject[lastactionObject.length-4],
				//	lastactionObject[lastactionObject.length-3],
				//	lastactionObject[lastactionObject.length-2],
				//	lastactionObject[lastactionObject.length-1],
                //    lastactionObject[lastactionObject.length-9]);
			} else if (actionObject[0]=='processgroup'){
				this.loadFixedProcessgroup_saveObj(lastactionObject[lastactionObject.length-8],
					lastactionObject[lastactionObject.length-7],
					lastactionObject[lastactionObject.length-5],
					lastactionObject[lastactionObject.length-4],
					lastactionObject[lastactionObject.length-3],
					lastactionObject[lastactionObject.length-2],
					lastactionObject[lastactionObject.length-1],
                    lastactionObject[lastactionObject.length-9],
                    lastactionObject[lastactionObject.length-10]
                    );
			} else if (actionObject[0]=='processtree'){
                if (this.diagramType == 1) {
	                this.loadFixedProcess(lastactionObject[lastactionObject.length-8],
	                    lastactionObject[lastactionObject.length-7],
	                    lastactionObject[lastactionObject.length-5],
	                    lastactionObject[lastactionObject.length-4],
	                    lastactionObject[lastactionObject.length-3],
	                    lastactionObject[lastactionObject.length-2],
	                    lastactionObject[lastactionObject.length-1],
                        lastactionObject[lastactionObject.length-9],
                        lastactionObject[lastactionObject.length-10]
                        );
                } else {   
                    //means this.diagramType == 2 or 4
                    //load/simulate a simple Process
	                this.loadProcess(lastactionObject[lastactionObject.length-8],
	                    lastactionObject[lastactionObject.length-7],
	                    lastactionObject[lastactionObject.length-5],
	                    lastactionObject[lastactionObject.length-4],
	                    lastactionObject[lastactionObject.length-3],
	                    lastactionObject[lastactionObject.length-2],
	                    lastactionObject[lastactionObject.length-1],
                        lastactionObject[lastactionObject.length-9],
                        lastactionObject[lastactionObject.length-10],
                        lastactionObject[lastactionObject.length-11]
                        );
                }
			} else if (actionObject[0]=='unitFixed'){
				if (this.diagramType == 3) {
					this.loadFixedUnit(lastactionObject[lastactionObject.length-8],
						lastactionObject[lastactionObject.length-7],
						lastactionObject[lastactionObject.length-5],
						lastactionObject[lastactionObject.length-4],
						lastactionObject[lastactionObject.length-3],
						lastactionObject[lastactionObject.length-2],
                        lastactionObject[lastactionObject.length-1],
                        lastactionObject[lastactionObject.length-9],
                        lastactionObject[lastactionObject.length-10]
                        );
				} else {	
                    //means this.diagramType == 2 Flow or MyRole Diagram
                    //load/simulate a simple Unit
					this.loadUnit(lastactionObject[lastactionObject.length-8],
						lastactionObject[lastactionObject.length-7],
						lastactionObject[lastactionObject.length-5],
						lastactionObject[lastactionObject.length-4],
						lastactionObject[lastactionObject.length-3],
						lastactionObject[lastactionObject.length-2],
						lastactionObject[lastactionObject.length-1],
                        lastactionObject[lastactionObject.length-9],
                        lastactionObject[lastactionObject.length-10],
                        lastactionObject[lastactionObject.length-11],
                        lastactionObject[lastactionObject.length-12],
                        false,lastactionObject[lastactionObject.length-13]
                        ); //Do not recalc the widht and height
				}
			} else if (actionObject[0]=='departementFixed'){
                if (this.diagramType == 2 || this.diagramType == 4) {
                    //Flow or MyRole Diagram
	                this.loadDepartement(lastactionObject[lastactionObject.length-8],
	                    lastactionObject[lastactionObject.length-7],
	                    lastactionObject[lastactionObject.length-5],
	                    lastactionObject[lastactionObject.length-4],
	                    lastactionObject[lastactionObject.length-3],
	                    lastactionObject[lastactionObject.length-2],
	                    lastactionObject[lastactionObject.length-1],
                        lastactionObject[lastactionObject.length-9],
                        lastactionObject[lastactionObject.length-10],
                        lastactionObject[lastactionObject.length-11],
                        lastactionObject[lastactionObject.length-12],
                        lastactionObject[lastactionObject.length-13]
                        );    
                } else {
                    this.loadFixedDepartement(lastactionObject[lastactionObject.length-8],
	                    lastactionObject[lastactionObject.length-7],
	                    lastactionObject[lastactionObject.length-5],
	                    lastactionObject[lastactionObject.length-4],
	                    lastactionObject[lastactionObject.length-3],
	                    lastactionObject[lastactionObject.length-2],
                        lastactionObject[lastactionObject.length-1],
                        lastactionObject[lastactionObject.length-9],
                        lastactionObject[lastactionObject.length-10]
                        );
                }
            } else if (actionObject[0]=='companyFixed'){
            	
            	//Stupid Laszlo Compilor does not allow functions to get too big
                this.sendWatchObjectCompany(action,actionObject,isWmlLoader,addInfos,lastactionObject);
                
			} else if (actionObject[0]=='unit'){
                //if ($debug) Debug.warn("ALERT THIS CANNOT HAPPEN: basedraw Line 1467 actionObject[0]==unit");
				//this.loadUnit(lastactionObject[lastactionObject.length-8],
				//	lastactionObject[lastactionObject.length-7],
				//	lastactionObject[lastactionObject.length-5],
				//	lastactionObject[lastactionObject.length-4],
				//	lastactionObject[lastactionObject.length-3],
				//	lastactionObject[lastactionObject.length-2],
				//	lastactionObject[lastactionObject.length-1]);
			} else if (actionObject[0]=='issueflow'){
				this.loadIssueflow(lastactionObject[lastactionObject.length-8],
					lastactionObject[lastactionObject.length-7],
					lastactionObject[lastactionObject.length-5],
					lastactionObject[lastactionObject.length-4],
					lastactionObject[lastactionObject.length-3],
					lastactionObject[lastactionObject.length-2],
					lastactionObject[lastactionObject.length-1],
                    lastactionObject[lastactionObject.length-9],
                    lastactionObject[lastactionObject.length-10],
                    lastactionObject[lastactionObject.length-11]
                    );
			} else if (actionObject[0]=='connector'){
                this.loadObjConnectorLine(lastactionObject);
            } else if (actionObject[0]=='connectorText'){
                this.loadObjConnectorText(lastactionObject);
            } else {
				if ($debug) Debug.warn("sendWatchObject Unkown Object Type: ",actionObject[0],lastactionObject);
			}
			
			//if ($debug) Debug.write("sendWatchObject ",addInfos);
			
			if (addInfos != null) {
				if (addInfos["drillDown"] != null && addInfos.drillDown) {
					this.currentlayer.setDrillDownFlag();
				}
				if (addInfos["surfAcross"] != null && addInfos.surfAcross) {
                    this.currentlayer.setSurfAcrossFlag();
                }
			}
            
            //this.baseactionobjectList.push(lastactionObject);
			//set counter to maximum otherwise trouble in naming conventions
			//the 6th array index count from the end of each object is always the counter of the
			//object
			this.compareAndSetCounter(lastactionObject[lastactionObject.length-6]);
			
			//this.baseactionobjectList.push(lastactionObject);
			
			//Send a notifcation for the library loader sothat it can show progress
			//and Browser does not hangUp and images can be proceed
			//only send if type ain#t image cause image will send its own one after 
			// it has been loaded completely
			if (isWmlLoader && actionObject[0]!='image' && isWmlLoader && actionObject[0]!='swf') {
				if (this.onwmlLoaderSend) this.onwmlLoaderSend.sendEvent(actionObject[0]);
			}
            
		} else {
			//Stupid Laszlo Compilor does not allow functions to get too big
			this.sendWatchObject_Continue(action,actionObject,isWmlLoader,addInfos);
		}
		
		//Add documents to shape
		//if ($debug) Debug.info("showDocuments -- ");
		this.currentlayer.showDocuments(diagramDocuments);
		
		]]>
	</method>
	
	<method name="sendWatchObjectCompany" args="action,actionObject,isWmlLoader,addInfos,lastactionObject">
		<![CDATA[
    		if (this.diagramType == 2 || this.diagramType == 4) {
                //Flow or MyRole Diagram
                this.loadCompany(lastactionObject[lastactionObject.length-8],
                    lastactionObject[lastactionObject.length-7],
                    lastactionObject[lastactionObject.length-5],
                    lastactionObject[lastactionObject.length-4],
                    lastactionObject[lastactionObject.length-3],
                    lastactionObject[lastactionObject.length-2],
                    lastactionObject[lastactionObject.length-1],
                    lastactionObject[lastactionObject.length-9],
                    lastactionObject[lastactionObject.length-10],
                    lastactionObject[lastactionObject.length-11],
                    lastactionObject[lastactionObject.length-12],
                    lastactionObject[lastactionObject.length-13]);
            } else {
                this.loadFixedCompany(lastactionObject[lastactionObject.length-8],
                    lastactionObject[lastactionObject.length-7],
                    lastactionObject[lastactionObject.length-5],
                    lastactionObject[lastactionObject.length-4],
                    lastactionObject[lastactionObject.length-3],
                    lastactionObject[lastactionObject.length-2],
                    lastactionObject[lastactionObject.length-1],
                    lastactionObject[lastactionObject.length-9],
                    lastactionObject[lastactionObject.length-10]);
            }
        ]]>
	</method>
	
	<!-- Stupid Laszlo Compilor does not allow functions to get too big -->
	<method name="sendWatchObject_Continue" args="action,actionObject,isWmlLoader,addInfos">
		<![CDATA[
		if(action=='clear'){
            this.clearAll();
        } else if(action=='delete' || action=='undo'){
            var lastactionObject = actionObject;    
            var obj = this.getObjectByName(lastactionObject[lastactionObject.length-1]);
            obj.destroy();
        } else if(action=='size'){
            var lastactionObject = actionObject;    
            var obj = this.getObjectByName(lastactionObject[lastactionObject.length-1]);
            obj.setAttribute('x',lastactionObject[lastactionObject.length-5]);
            obj.setAttribute('y',lastactionObject[lastactionObject.length-4]);
            obj.setAttribute('width',lastactionObject[lastactionObject.length-3]);
            obj.setAttribute('height',lastactionObject[lastactionObject.length-2]);
        } else if (action=="loadwml"){
            //Debug.write(actionObject,actionObject["wmlfileName"],actionObject["wmlroom"],actionObject["wmldomain"]);
            this.remoteWmlLoader(actionObject["wmlfileName"],actionObject["wmlroom"],actionObject["wmldomain"]);
        } else if (action=="editText"){
            this.editTextByHistory(actionObject,this);
        } else if (action=="initgetVars"){
            //Debug.write("initUser isMod ",canvas.ismoderator,actionObject);
            if (canvas.ismoderator){
                //Debug.write("send all whiteBoard objects to new user");
                var obj = new Array();
                obj[0] = 'whiteboard';
                obj[1] = 'inituser';
                obj[2] = this.baseactionobjectList;
                this.oninitUser(actionObject,obj);
            }
        } else if (action=="swf"){
            this.remoteObjectUpdate(actionObject);  
        }
		
		]]>
	</method>
	
	
	<!--
	 @deprecated
	<method name="sendRecordedObject" args="action,actionObject,isWmlLoader">
		//Debug.write("sendWatchObject: ",action,actionObject);
		<![CDATA[
		if (action=='draw' || action=='redo'){
			var lastactionObject = actionObject;
			
			//Redraw the View on the paintarea
			if (actionObject[0]=='paint'){
				this.paintactionHistory(lastactionObject,this);
			} else if (actionObject[0]=='line'){
				this.lineactionHistory(lastactionObject,this);
			} else if (actionObject[0]=='uline'){
				this.ulineactionHistory(lastactionObject,this);
			} else if (actionObject[0]=='drawarrow'){
				this.drawarrowlineactionHistory(lastactionObject,this);
			} else if(action,actionObject[0]=='letter'){
				this.drawactionHistory(lastactionObject,this);
			} else if(actionObject[0]=='image'){
				//Image will send the onwmlLoaderSend later cause it has to be send
				//once the image has been loaded completely
				this.addImageToLayerHistoryRecorded(lastactionObject,this,isWmlLoader);
			} else if(actionObject[0]=='swf'){
				//Image will send the onwmlLoaderSend later cause it has to be send
				//once the image has been loaded completely
				this.addSWFToLayerHistoryRecording(lastactionObject,this,isWmlLoader);
			} else if(actionObject[0]=='rectangle'){
				this.drawrectangleToHistory(lastactionObject,this);
			} else if(actionObject[0]=='ellipse'){
				this.drawellipseToHistory(lastactionObject,this);
			}
			//set counter to maximum otherwise trouble in naming conventions
			//the 6th array index count from the end of each object is always the counter of the
			//object
			this.compareAndSetCounter(lastactionObject[lastactionObject.length-6]);
			this.baseactionobjectList.push(lastactionObject);
			
			//Send a notifcation for the library loader sothat it can show progress
			//and Browser does not hangUp and images can be proceed
			//only send if type ain#t image cause image will send its own one after 
			// it has been loaded completely
			if (isWmlLoader && actionObject[0]!='image' && isWmlLoader && actionObject[0]!='swf') {
				if (this.onwmlLoaderSend) this.onwmlLoaderSend.sendEvent(actionObject[0]);
			}
            
		} else if(action=='clear'){
			this.clearAll();
		} else if(action=='delete' || action=='undo'){
			var lastactionObject = actionObject;	
			var obj = this.getObjectByName(lastactionObject[lastactionObject.length-1]);
			obj.destroy();
		} else if(action=='size'){
			var lastactionObject = actionObject;	
			var obj = this.getObjectByName(lastactionObject[lastactionObject.length-1]);
			obj.setAttribute('x',lastactionObject[lastactionObject.length-5]);
			obj.setAttribute('y',lastactionObject[lastactionObject.length-4]);
			obj.setAttribute('width',lastactionObject[lastactionObject.length-3]);
			obj.setAttribute('height',lastactionObject[lastactionObject.length-2]);
		} else if (action=="loadwml"){
			//Debug.write(actionObject,actionObject["wmlfileName"],actionObject["wmlroom"],actionObject["wmldomain"]);
			this.remoteWmlLoaderRecording(actionObject["wmlfileName"],actionObject["wmlroom"],actionObject["wmldomain"]);
		} else if (action=="editText"){
			this.editTextByHistory(actionObject,this);
		} else if (action=="initgetVars"){
			//Debug.write("initUser isMod ",canvas.ismoderator,actionObject);
			if (canvas.ismoderator){
				//Debug.write("send all whiteBoard objects to new user");
				var obj = new Array();
			    obj[0] = 'whiteboard';
			    obj[1] = 'inituser';
			    obj[2] = this.baseactionobjectList;
				this.oninitUser(actionObject,obj);
			}
		} else if (action=="swf"){
			this.remoteObjectUpdate(actionObject);	
		}
		]]>
	</method>
	 -->
	
	<!-- #####################
		Paint
	 -->
	
  	<method name="drawline" args="x1,y1,x2,y2">
	    <![CDATA[
	    currentlayer.beginPath();
	    currentlayer.moveTo(x1,y1);
	    currentlayer.lineTo(x2,y2);
	    currentlayer.stroke();
	    ]]>
	</method>
	
  	<method name="drawlineOnObject" args="obj,x1,y1,x2,y2">
	    <![CDATA[
	    obj.beginPath();
	    obj.moveTo(x1,y1);
	    obj.lineTo(x2,y2);
	    obj.stroke();
	    ]]>
	</method>
		
	
	<method name="drawlineRegisterPaint" args="x1,y1,x2,y2">
	    var actionObject = new Array();
	    actionObject[0] = 'point';
	    actionObject[1] = x1;
	    actionObject[2] = y1;
	    actionObject[3] = x2;
	    actionObject[4] = y2;
	    this.basetempactionobjectList.push(actionObject);
	</method>
	
  	<method name="startPaint">
		//Debug.write("startPaint ",this.startx,this.starty);
    	this.currentlayer = new lz.drawViewNew(this,{name:'paint'+this.getCounter(),width:this.width+2,height:this.height+2});
		this.drawlineOnObject(this.currentlayer,-1,-1,0,0);
		this.drawlineOnObject(this.currentlayer,this.width,this.height,this.width+1,this.height+1);
  	
    	//Set previous to null
    	this.prevx = null;
    	this.prevy = null;  
	    
	    currentlayer.strokeStyle = this.currentlayerstroke;
	    currentlayer.lineWidth = this.currentlayerlineWidth;
	    currentlayer.fillstyle = '0x000000';
	    
	    this.basetempactionobjectList = new Array();
	    
	    //beginFill( the_colorpicker.selectedColor );
  	</method>

  	<method name="endPaint">
  		////Debug.write("endPaint");
		<![CDATA[
		var tempName = this.currentlayer.name;
		this.currentlayer.destroy();
		
		//GetBounds of that Object
		var minx = this.width+2;
		var miny = this.height+2;
		var maxx = -2;
		var maxy = -2;
		
		for (var eg=0;eg<this.basetempactionobjectList.length;eg++){
			////Debug.write(this.basetempactionobjectList[eg][1],this.basetempactionobjectList[eg][3]);
   			if (this.basetempactionobjectList[eg][1]<minx) minx=this.basetempactionobjectList[eg][1];
   			if (this.basetempactionobjectList[eg][3]<minx) minx=this.basetempactionobjectList[eg][3];
   			
   			if (this.basetempactionobjectList[eg][1]>maxx) maxx=this.basetempactionobjectList[eg][1];
   			if (this.basetempactionobjectList[eg][3]>maxx) maxx=this.basetempactionobjectList[eg][3];
   			
   			if (this.basetempactionobjectList[eg][2]<miny) miny=this.basetempactionobjectList[eg][2];
   			if (this.basetempactionobjectList[eg][4]<miny) miny=this.basetempactionobjectList[eg][4];
   			
   			if (this.basetempactionobjectList[eg][2]>maxy) maxy=this.basetempactionobjectList[eg][2];
   			if (this.basetempactionobjectList[eg][4]>maxy) maxy=this.basetempactionobjectList[eg][4];
   		}
   		var width = maxx-minx;
   		var height = maxy-miny;
   		////Debug.write("## 1 ## NEW x,y ",minx,miny," width,height: ",width,height);
   		
		this.currentlayer = new lz.drawViewNew(this,{name:tempName,x:minx-1,y:miny-1,width:width,height:height});
    	this.currentlayer.fillstyle = '0x000000';
    	this.currentlayer.lineWidth = this.currentlayerlineWidth;
   		this.currentlayer.strokeStyle = this.currentlayerstroke;
   		
   		for (var eg=0;eg<this.basetempactionobjectList.length;eg++) 
   			this.drawline(this.basetempactionobjectList[eg][1]-minx,this.basetempactionobjectList[eg][2]-miny,this.basetempactionobjectList[eg][3]-minx,this.basetempactionobjectList[eg][4]-miny)
   			
   		//this.currentlayer.setAttribute('stretches','both');
    	
    	//Add Layer to global Layer  	
	    this.layers.push(this.currentlayer);   		

   		]]>
   		
   		this.registerFinal();
  	</method>    

  	<method name="registerFinal">
		var actionObject = new Array();
	    actionObject[0] = 'paint';
	    actionObject[1] = this.basetempactionobjectList;
	    actionObject[2] = currentlayer.fillstyle;
	    actionObject[3] = currentlayer.lineWidth;
	    actionObject[4] = currentlayer.strokeStyle;
		actionObject[5] = this.counter;
	    actionObject[6] = currentlayer.x;
	    actionObject[7] = currentlayer.y;
	    actionObject[8] = currentlayer.width;
	    actionObject[9] = currentlayer.height;	   
	    actionObject[10] = this.currentlayer.name;
	    this.baseactionobjectList.push(actionObject);		
	    this.onsharedMessage('draw',actionObject);
  	</method>      
	
	
	<method name="paintactionHistory" args="lastActionObject,parentView">
		<![CDATA[
		//Debug.write("## paintactionHistory",parentView," 2 ## NEW lastActionObject[5],lastActionObject[6] ",lastActionObject[5],lastActionObject[6]," width,height: ",lastActionObject[7],lastActionObject[8]);
		
		this.currentlayer = new lz.drawViewNew(parentView,{name:lastActionObject[lastActionObject.length-1],x:lastActionObject[lastActionObject.length-5],y:lastActionObject[lastActionObject.length-4],width:lastActionObject[lastActionObject.length-3],height:lastActionObject[lastActionObject.length-2]});
		
    	this.currentlayer.fillstyle = lastActionObject[2];
    	this.currentlayer.lineWidth = lastActionObject[3];
   		this.currentlayer.strokeStyle = lastActionObject[4];
   		
   		for (var eg=0;eg<lastActionObject[1].length;eg++) 
   			this.drawline(lastActionObject[1][eg][1]-this.currentlayer.x,lastActionObject[1][eg][2]-this.currentlayer.y,lastActionObject[1][eg][3]-this.currentlayer.x,lastActionObject[1][eg][4]-this.currentlayer.y);
   		
   		//this.currentlayer.setAttribute('stretches','both');
   		]]>
	</method>
    
    <!-- ###########################
    Line
     -->
  	
  	<method name="startLine">
		//Debug.write("startLine ",this.startx,this.starty);
    	this.currentlayer = new lz.drawViewNew(this,{name:'line'+this.getCounter(),width:this.width+2,height:this.height+2});
		this.drawlineOnObject(this.currentlayer,-1,-1,0,0);
		this.drawlineOnObject(this.currentlayer,this.width,this.height,this.width+1,this.height+1);
  	
    	//Set previous to null
    	this.prevx = null;
    	this.prevy = null;  
	    
	    currentlayer.strokeStyle = this.currentlinestroke;
	    currentlayer.lineWidth = this.currentlinelineWidth;
	    currentlayer.fillstyle = '0x000000';

  	</method>
  	
  	<method name="endLine">
  		////Debug.write("endLine",this.startx,this.starty,this.endx,this.endy);
		<![CDATA[
		var tempName = this.currentlayer.name;
		this.currentlayer.destroy();
		
		//GetBounds of that Object
		var minx = this.width+2;
		var miny = this.height+2;
		var maxx = -2;
		var maxy = -2;

		if (this.startx<minx) minx=this.startx;
		if (this.endx<minx) minx=this.endx;
		
		if (this.startx>maxx) maxx=this.startx;
		if (this.endx>maxx) maxx=this.endx;
		
		if (this.starty<miny) miny=this.starty;
		if (this.endy<miny) miny=this.endy;
		
		if (this.starty>maxy) maxy=this.starty;
		if (this.endy>maxy) maxy=this.endy;
		
   		var width = maxx-minx;
   		var height = maxy-miny;

		this.currentlayer = new lz.drawViewNew(this,{name:tempName,x:(minx-1-(this.currentlinelineWidth/2)),y:(miny-1-(this.currentlinelineWidth/2)),width:(width+this.currentlinelineWidth),height:(height+this.currentlinelineWidth)});
    	this.currentlayer.fillstyle = '0x000000';
    	this.currentlayer.lineWidth = this.currentlinelineWidth;
   		this.currentlayer.strokeStyle = this.currentlinestroke;

   		this.drawline((this.startx-minx+(this.currentlinelineWidth/2)),(this.starty-miny+(this.currentlinelineWidth/2)),(this.endx-minx+(this.currentlinelineWidth/2)),(this.endy-miny+(this.currentlinelineWidth/2)));

    	//Add Layer to global Layer  	
	    this.layers.push(this.currentlayer);  
		]]>
		this.lineregisterFinal();
  	</method> 
  	
  	
  	<method name="lineregisterFinal">
		var actionObject = new Array();
	    actionObject[0] = 'line';
	    actionObject[1] = currentlayer.fillstyle;
	    actionObject[2] = currentlayer.lineWidth;
	    actionObject[3] = currentlayer.strokeStyle;
	    actionObject[4] = this.startx;	
	    actionObject[5] = this.starty;	
	    actionObject[6] = this.endx;	
	    actionObject[7] = this.endy;	
		actionObject[8] = this.counter;    
	    actionObject[9] = currentlayer.x;
	    actionObject[10] = currentlayer.y;
	    actionObject[11] = currentlayer.width;
	    actionObject[12] = currentlayer.height;	 
	    actionObject[13] = this.currentlayer.name;
	    this.baseactionobjectList.push(actionObject);		
	    this.onsharedMessage('draw',actionObject);
  	</method>     	
  	
	
	<method name="lineactionHistory" args="lastActionObject,parentView">
		<![CDATA[
		//Debug.write("## lineactionHistory",parentView," 2 ## NEW x,y ",lastActionObject[lastActionObject.length-5],lastActionObject[lastActionObject.length-4]," width,height: ",lastActionObject[lastActionObject.length-3],lastActionObject[lastActionObject.length-2]);
		
		this.currentlayer = new lz.drawViewNew(parentView,{name:lastActionObject[lastActionObject.length-1],x:lastActionObject[lastActionObject.length-5],y:lastActionObject[lastActionObject.length-4],width:lastActionObject[lastActionObject.length-3],height:lastActionObject[lastActionObject.length-2]});
		
    	this.currentlayer.fillstyle = lastActionObject[1];
    	this.currentlayer.lineWidth = lastActionObject[2];
   		this.currentlayer.strokeStyle = lastActionObject[3];

   		this.drawline(lastActionObject[4]-this.currentlayer.x,lastActionObject[5]-this.currentlayer.y,lastActionObject[6]-this.currentlayer.x,lastActionObject[7]-this.currentlayer.y);

   		]]>
	</method>
	
	<!-- ###########################
	Underline
	 -->
    <method name="startUline">
		//Debug.write("startUline ",this.startx,this.starty);
    	this.currentlayer = new lz.drawViewNew(this,{opacity:0.5,name:'uline'+this.getCounter(),width:this.width+2,height:this.height+2});
		this.drawlineOnObject(this.currentlayer,-1,-1,0,0);
		this.drawlineOnObject(this.currentlayer,this.width,this.height,this.width+1,this.height+1);
  	
    	//Set previous to null
    	this.prevx = null;
    	this.prevy = null;  
	    
	    currentlayer.strokeStyle = this.currentulinestroke;
	    currentlayer.lineWidth = this.currentulinelineWidth;
	    currentlayer.fillstyle = '0x000000';
  	</method>  
    
  	<method name="endUline">
  		//Debug.write("endUline",this.startx,this.starty,this.endx,this.endy);
		<![CDATA[
		var tempName = this.currentlayer.name;
		//Debug.write("tempName: ",tempName);
		this.currentlayer.destroy();
		
		//GetBounds of that Object
		var minx = this.width+2;
		var miny = this.height+2;
		var maxx = -2;
		var maxy = -2;

		if (this.startx<minx) minx=this.startx;
		if (this.endx<minx) minx=this.endx;
		
		if (this.startx>maxx) maxx=this.startx;
		if (this.endx>maxx) maxx=this.endx;
		
		if (this.starty<miny) miny=this.starty;
		if (this.endy<miny) miny=this.endy;
		
		if (this.starty>maxy) maxy=this.starty;
		if (this.endy>maxy) maxy=this.endy;
		
   		var width = maxx-minx;
   		var height = maxy-miny;
   		
   		//Debug.write("minx,miny,width,height: ",minx,miny,width,height);
   		
		this.currentlayer = new lz.drawViewNew(this,{opacity:0.5,name:tempName,x:(minx-1-(this.currentulinelineWidth/2)),y:(miny-1-(this.currentulinelineWidth/2)),width:(width+this.currentulinelineWidth),height:(height+this.currentulinelineWidth)});
    	this.currentlayer.fillstyle = '0x000000';
    	this.currentlayer.lineWidth = this.currentulinelineWidth;
   		this.currentlayer.strokeStyle = this.currentulinestroke;

   		this.drawline((this.startx-minx+(this.currentulinelineWidth/2)),(this.starty-miny+(this.currentulinelineWidth/2)),(this.endx-minx+(this.currentulinelineWidth/2)),(this.endy-miny+(this.currentulinelineWidth/2)));

    	
    	//Add Layer to global Layer  	
	    this.layers.push(this.currentlayer);  
		]]>
		this.ulineregisterFinal();
  	</method> 
  	
  	
  	<method name="ulineregisterFinal">
		var actionObject = new Array();
	    actionObject[0] = 'uline';
	    actionObject[1] = currentlayer.fillstyle;
	    actionObject[2] = currentlayer.lineWidth;
	    actionObject[3] = currentlayer.strokeStyle;
	    actionObject[4] = this.startx;	
	    actionObject[5] = this.starty;	
	    actionObject[6] = this.endx;	
	    actionObject[7] = this.endy;	
		actionObject[8] = this.counter;    
	    actionObject[9] = currentlayer.x;
	    actionObject[10] = currentlayer.y;
	    actionObject[11] = currentlayer.width;
	    actionObject[12] = currentlayer.height;	 
	    actionObject[13] = this.currentlayer.name;
	    this.baseactionobjectList.push(actionObject);		
	    this.onsharedMessage('draw',actionObject);
  	</method>     	
  	
	
	<method name="ulineactionHistory" args="lastActionObject,parentView">
		<![CDATA[
		//Debug.write("## lineactionHistory",parentView," 2 ## NEW x,y ",lastActionObject[lastActionObject.length-5],lastActionObject[lastActionObject.length-4]," width,height: ",lastActionObject[lastActionObject.length-3],lastActionObject[lastActionObject.length-2]);
		
		this.currentlayer = new lz.drawViewNew(parentView,{opacity:0.5,name:lastActionObject[lastActionObject.length-1],x:lastActionObject[lastActionObject.length-5],y:lastActionObject[lastActionObject.length-4],width:lastActionObject[lastActionObject.length-3],height:lastActionObject[lastActionObject.length-2]});
		
    	this.currentlayer.fillstyle = lastActionObject[1];
    	this.currentlayer.lineWidth = lastActionObject[2];
   		this.currentlayer.strokeStyle = lastActionObject[3];

   		this.drawline(lastActionObject[4]-this.currentlayer.x,lastActionObject[5]-this.currentlayer.y,lastActionObject[6]-this.currentlayer.x,lastActionObject[7]-this.currentlayer.y);

   		]]>
	</method>
	
	<!-- ###########################
	drawarrow
	 -->
    <method name="startDrawarrowline">
    	<![CDATA[
    	this.currentlayer = new lz.drawViewNew(this,{name:'drawarrow'+this.getCounter(),width:this.width+2,height:this.height+2});
		this.drawlineOnObject(this.currentlayer,-1,-1,0,0);
		this.drawlineOnObject(this.currentlayer,this.width,this.height,this.width+1,this.height+1);
  		
  		//Add Resource
  		var t = new lz.drawArrowWhiteBoard(this.currentlayer,{x:this.startx,y:this.starty});
  		
  		//Color
    	t.setTint(this.currentdrawarrowlinestroke,100);
    	
    	var tx = this.currentlayer.getMouse('x')-this.startx;
    	var ty = this.currentlayer.getMouse('y')-this.starty;

   		var gegenkathete = Math.abs(ty);
   		var ankathete = Math.abs(tx); 
   		var hypothenuse = Math.sqrt((ankathete*ankathete)+(gegenkathete*gegenkathete));
   		var sinAlpha = (gegenkathete/hypothenuse);
   		var alpha = Math.asin(sinAlpha);
		alpha = alpha/(Math.PI/180);
			
    	if (tx>=0 && ty>=0){  	
    		t.setAttribute('rotation',(alpha-45));
    	} else if (tx<0 && ty>=0){
    		t.setAttribute('rotation',(45+90-alpha));
    	} else if (tx<0 && ty<0){
    		t.setAttribute('rotation',(alpha+45+90));
    	} else if (tx>0 && ty<=0){
    		t.setAttribute('rotation',(45-alpha-90));
    	}
    	
    	//Scaling
    	var basicLength = Math.sqrt((t.width*t.width)+(t.width*t.width));
    	t.getMCRef()._xscale = (hypothenuse/basicLength)*100;
    	t.getMCRef()._yscale = (hypothenuse/basicLength)*100;
    	

    	//Set previous to null
    	this.prevx = null;
    	this.prevy = null;  
	    
	    currentlayer.strokeStyle = this.currentdrawarrowlinestroke;
	    currentlayer.lineWidth = this.currentdrawarrowlinelineWidth;
	    currentlayer.fillstyle = '0x000000';
	    ]]>
  	</method>  
    
  	<method name="endDrawarrowline">
  		//Debug.write("endDrawarrowline",this.startx,this.starty,this.endx,this.endy);
		<![CDATA[
		var tempName = this.currentlayer.name;
		//Debug.write("tempName: ",tempName);
		this.currentlayer.destroy();
		
		//GetBounds of that Object
		var minx = this.width+2;
		var miny = this.height+2;
		var maxx = -2;
		var maxy = -2;

		if (this.startx<minx) minx=this.startx;
		if (this.endx<minx) minx=this.endx;
		
		if (this.startx>maxx) maxx=this.startx;
		if (this.endx>maxx) maxx=this.endx;
		
		if (this.starty<miny) miny=this.starty;
		if (this.endy<miny) miny=this.endy;
		
		if (this.starty>maxy) maxy=this.starty;
		if (this.endy>maxy) maxy=this.endy;
		
   		var width = maxx-minx;
   		var height = maxy-miny;
   		
   		//Debug.write("minx,miny,width,height: ",minx,miny,width,height);

		this.currentlayer = new lz.drawViewNew(this,{name:tempName,x:minx-1,y:miny-1,width:width,height:height});
    	this.currentlayer.fillstyle = '0x000000';
    	this.currentlayer.lineWidth = this.currentdrawarrowlinelineWidth;
   		this.currentlayer.strokeStyle = this.currentdrawarrowlinestroke;
   		
   		//Debug.write("this.currentlayer: ",this.currentlayer);

		var t = new lz.drawArrowWhiteBoard(this.currentlayer,{x:0,y:0});

  		//Color
    	t.setTint(this.currentdrawarrowlinestroke,100);
    	
    	var tx = this.endx-this.startx;
    	var ty = this.endy-this.starty;

   		var gegenkathete = Math.abs(ty);
   		var ankathete = Math.abs(tx); 
   		var hypothenuse = Math.sqrt((ankathete*ankathete)+(gegenkathete*gegenkathete));
   		var sinAlpha = (gegenkathete/hypothenuse);
   		var alpha = Math.asin(sinAlpha);
		alpha = alpha/(Math.PI/180);
			
		var newx = 0;
		var newy = 0;
    	if (tx>=0 && ty>=0){  	
    		t.setAttribute('rotation',(alpha-45));
    	} else if (tx<0 && ty>=0){
    		newx = width;
    		t.setAttribute('rotation',(45+90-alpha));
    	} else if (tx<0 && ty<0){
    		newy = height;
    		newx = width;
    		t.setAttribute('rotation',(alpha+45+90));
    	} else if (tx>0 && ty<=0){
    		newy = height;
    		t.setAttribute('rotation',(45-alpha-90));
    	}
    	
    	t.setAttribute('x',newx);
    	t.setAttribute('y',newy);
    	
    	//Scaling
    	var basicLength = Math.sqrt((t.width*t.width)+(t.width*t.width));
    	t.getMCRef()._xscale = (hypothenuse/basicLength)*100;
    	t.getMCRef()._yscale = (hypothenuse/basicLength)*100;
    	

    	//Set previous to null
    	this.prevx = null;
    	this.prevy = null;  
    	
    	//Add Layer to global Layer  	
	    this.layers.push(this.currentlayer);  
		]]>
		this.drawarrowlineregisterFinal();
		this.currentlayer = new LzView();
		//Debug.write("t: ",t);
  	</method> 
  	
  	
  	<method name="drawarrowlineregisterFinal">
		var actionObject = new Array();
	    actionObject[0] = 'drawarrow';
	    actionObject[1] = currentlayer.fillstyle;
	    actionObject[2] = currentlayer.lineWidth;
	    actionObject[3] = currentlayer.strokeStyle;
	    actionObject[4] = this.startx;	
	    actionObject[5] = this.starty;	
	    actionObject[6] = this.endx;	
	    actionObject[7] = this.endy;	 
		actionObject[8] = this.counter;   
	    actionObject[9] = currentlayer.x;
	    actionObject[10] = currentlayer.y;
	    actionObject[11] = currentlayer.width;
	    actionObject[12] = currentlayer.height;	 
	    actionObject[13] = this.currentlayer.name;
	    this.baseactionobjectList.push(actionObject);		
	    this.onsharedMessage('draw',actionObject);
  	</method>     	
  	
	
	<method name="drawarrowlineactionHistory" args="lastActionObject,parentView">
		<![CDATA[
			//Debug.write("## lineactionHistory",parentView," 2 ## NEW x,y ",lastActionObject[lastActionObject.length-5],lastActionObject[lastActionObject.length-4]," width,height: ",lastActionObject[lastActionObject.length-3],lastActionObject[lastActionObject.length-2]);
			
			this.currentlayer = new lz.drawViewNew(parentView,{name:lastActionObject[lastActionObject.length-1],x:lastActionObject[lastActionObject.length-5],y:lastActionObject[lastActionObject.length-4],width:lastActionObject[lastActionObject.length-3],height:lastActionObject[lastActionObject.length-2]});
			
			var t = new lz.drawArrowWhiteBoard(this.currentlayer,{x:0,y:0});
			
			t.setTint(lastActionObject[3],100);
	    	
	    	var tx = lastActionObject[6]-lastActionObject[4];
	    	var ty = lastActionObject[7]-lastActionObject[5];
	
	   		var gegenkathete = Math.abs(ty);
	   		var ankathete = Math.abs(tx); 
	   		var hypothenuse = Math.sqrt((ankathete*ankathete)+(gegenkathete*gegenkathete));
	   		var sinAlpha = (gegenkathete/hypothenuse);
	   		var alpha = Math.asin(sinAlpha);
			var alpha = alpha/(Math.PI/180);
				
			var newx = 0;
			var newy = 0;
	    	if (tx>=0 && ty>=0){  	
	    		t.setAttribute('rotation',(alpha-45));
	    	} else if (tx<0 && ty>=0){
	    		newx = lastActionObject[lastActionObject.length-3];
	    		t.setAttribute('rotation',(45+90-alpha));
	    	} else if (tx<0 && ty<0){
	    		newy = lastActionObject[lastActionObject.length-2];
	    		newx = lastActionObject[lastActionObject.length-3];
	    		t.setAttribute('rotation',(alpha+45+90));
	    	} else if (tx>0 && ty<=0){
	    		newy = lastActionObject[lastActionObject.length-2];
	    		t.setAttribute('rotation',(45-alpha-90));
	    	}
	    	
	    	t.setAttribute('x',newx);
	    	t.setAttribute('y',newy);
	    	
	    	//Scaling
	    	var basicLength = Math.sqrt((t.width*t.width)+(t.width*t.width));
	    	t.getMCRef()._xscale = (hypothenuse/basicLength)*100;
	    	t.getMCRef()._yscale = (hypothenuse/basicLength)*100;
	    	
	    	this.currentlayer.fillstyle = lastActionObject[1];
	    	this.currentlayer.lineWidth = lastActionObject[2];
	   		this.currentlayer.strokeStyle = lastActionObject[3];

   		]]>
	</method>
    
    
    <!-- ###########################
    Rectangle
     -->
    
  	<method name="startRect">
		//Debug.write("startRect");
    	this.currentlayer = new lz.drawViewNew(this,{name:'rectangle'+this.getCounter(),width:this.width+2,height:this.height+2});
		this.drawlineOnObject(this.currentlayer,-1,-1,0,0);
		this.drawlineOnObject(this.currentlayer,this.width,this.height,this.width+1,this.height+1);
  	</method>  

	<method name="endRect">
		<![CDATA[
			////Debug.write(" this.startx, this.starty , this.endx, this.endy ",this.startx, this.starty , this.endx, this.endy);
			this.currentlayer.destroy();
			var x = this.startx;
			var width = this.endx - this.startx;
			if (this.endx<this.startx){
				x = this.endx;
				width = Math.abs(width);
			}
			var y = this.starty;
			var height = this.endy - this.starty;
			if (this.endy<this.starty){
				y = this.endy;
				height = Math.abs(height);
			}
			
			this.currentlayer = new lz.drawViewNew(this,{name:'rectangle'+this.getCounter(),x:x,y:y,width:width,height:height});
			this.drawrectangleHistory(this.currentlayer,0,0,width,height,this.currentrectanglestroke,this.currentrectangleineWidth,this.currentrectanglestrokeFill,this.currentrectanglestrokeDis,this.currentrectanglestrokeFillDis);
			this.currentlayer.setAttribute('stretches','both');
			this.drawrectregisterFinal(this.currentlayer.name,this.currentrectanglestroke,this.currentrectangleineWidth,this.currentrectanglestrokeFill,this.currentrectanglestrokeDis,this.currentrectanglestrokeFillDis,x,y,width,height);
			this.checkStepLayers();
		]]>
	</method> 
    
  	<method name="drawrectangle" args="x1,y1,x2,y2">
   		<![CDATA[
    		
    		currentlayer.lineWidth = this.currentrectangleineWidth;
    		currentlayer.beginPath();
    		currentlayer.moveTo(x1,y1);
    		currentlayer.lineTo(x1,y2);
    		currentlayer.lineTo(x2,y2);
    		currentlayer.lineTo(x2,y1);
    		currentlayer.lineTo (x1,y1);
    		this.closePath();
    		
    		if (this.currentrectanglestrokeDis!=-1){
	    		currentlayer.strokeStyle = this.currentrectanglestroke;
	    		currentlayer.stroke();
    		}

    		if (this.currentrectanglestrokeFillDis!=-1){
	    		currentlayer.fillStyle = this.currentrectanglestrokeFill;
	    		currentlayer.fill();
    		}
    		
    	]]>   
  	</method>    
  	
  	<method name="drawrectangleToHistory" args="lastActionObject,parentView">
		this.currentlayer = new lz.drawViewNew(parentView,{name:lastActionObject[lastActionObject.length-1],x:lastActionObject[lastActionObject.length-5],y:lastActionObject[lastActionObject.length-4],width:lastActionObject[lastActionObject.length-3],height:lastActionObject[lastActionObject.length-2]});
   		this.drawrectangleHistory(this.currentlayer,0,0,lastActionObject[lastActionObject.length-3],lastActionObject[lastActionObject.length-2],lastActionObject[1],lastActionObject[2],lastActionObject[3],lastActionObject[4],lastActionObject[5]);
  	</method>
    
  	<method name="drawrectangleHistory" args="parentObj,x1,y1,x2,y2,stroke,line,fill,strokeDis,fillDis">
   		<![CDATA[
    		Debug.write("drawrectangleHistory",parentObj,x1,y1,x2,y2,stroke,line,fill,strokeDis,fillDis);
    		parentObj.lineWidth = line;
    		parentObj.beginPath();
    		parentObj.moveTo(x1,y1);
    		parentObj.lineTo(x1,y2);
    		parentObj.lineTo(x2,y2);
    		parentObj.lineTo(x2,y1);
    		parentObj.lineTo (x1,y1);
    		
    		if (strokeDis!=-1){
	    		parentObj.strokeStyle = stroke;
	    		parentObj.stroke();
    		}
    		
    		if (fillDis!=-1){
	    		parentObj.fillStyle = fill;
	    		parentObj.fill();
    		}
    	]]>   
  	</method>  
  	
  	<method name="drawrectregisterFinal" args="newName,stroke,line,fill,strokeDis,fillDis,x,y,width,height" >
  		//if ($debug) Debug.write("drawrectregisterFinal",newName,stroke,line,fill,strokeDis,fillDis,x,y,width,height);
		var actionObject = new Array();
	    actionObject[0] = 'rectangle';
	    actionObject[1] = stroke;
	    actionObject[2] = line;
	    actionObject[3] = fill;
	    actionObject[4] = strokeDis;
	    actionObject[5] = fillDis;
		actionObject[6] = this.counter;
	    actionObject[7] = x;
	    actionObject[8] = y;
	    actionObject[9] = width;
	    actionObject[10] = height;	    
	    actionObject[11] = newName;
	    this.baseactionobjectList.push(actionObject);
	    this.onsharedMessage('draw',actionObject);
  	</method>
  	
  	
  	<!-- ################
  	Ellipse
  	 -->
  	<method name="startEllipse">
		//Debug.write("startEllipse");
    	this.currentlayer = new lz.drawViewNew(this,{name:'ellipse'+this.getCounter(),width:this.width+2,height:this.height+2});
		this.drawlineOnObject(this.currentlayer,-1,-1,0,0);
		this.drawlineOnObject(this.currentlayer,this.width,this.height,this.width+1,this.height+1);
  	</method>    
  	
  	<method name="endEllipse">
  		<![CDATA[
			////Debug.write(" this.startx, this.starty , this.endx, this.endy ",this.startx, this.starty , this.endx, this.endy);
			this.currentlayer.destroy();
			var x = this.startx;
			var width = this.endx - this.startx;
			if (this.endx<this.startx){
				x = this.endx;
				width = Math.abs(width);
			}
			var y = this.starty;
			var height = this.endy - this.starty;
			if (this.endy<this.starty){
				y = this.endy;
				height = Math.abs(height);
			}
			
			this.currentlayer = new lz.drawViewNew(this,{name:'ellipse'+this.getCounter(),x:x,y:y,width:width,height:height});
			this.drawellipse(0,0,width,height);
			//Debug.write("this.currentellipsestroke,this.currentellipselineWidth: ",this.currentellipsestroke,this.currentellipselineWidth);
			this.drawellipseregisterFinal(this.currentlayer.name,this.currentellipsestroke,this.currentellipselineWidth,this.currentellipsestrokeFill,this.currentellipsestrokeDis,this.currentellipsestrokeFillDis,x,y,width,height);
			this.layers.push(this.currentlayer);
			this.checkStepLayers();
		]]>
  	</method>
  	
  	<method name="drawellipseToHistory"  args="lastActionObject,parentView">

		this.currentlayer = new lz.drawViewNew(parentView,{name:lastActionObject[lastActionObject.length-1],x:lastActionObject[lastActionObject.length-5],y:lastActionObject[lastActionObject.length-4],width:lastActionObject[lastActionObject.length-3],height:lastActionObject[lastActionObject.length-2]});
   		//Debug.write("lastActionObject[1],lastActionObject[2]: ",lastActionObject[1],lastActionObject[2]);
   		this.drawellipseHistory(this.currentlayer,0,0,lastActionObject[lastActionObject.length-3],lastActionObject[lastActionObject.length-2],lastActionObject[1],lastActionObject[2],lastActionObject[3],lastActionObject[4],lastActionObject[5]);

  	</method>
    
  	<method name="drawellipseHistory" args="parentObj,x1,y1,x2,y2,stroke,line,fill,strokeDis,fillDis">
   		<![CDATA[
   			//Debug.write("stroke,line: ",stroke,line);
	    	var rx = (x1+x2)/2;
	    	var ry = (y1+y2)/2;
	    	var xradius = Math.abs(rx-x1);
	    	var yradius = Math.abs(ry-y1);
	    	
	    	parentObj.lineWidth = line;
	    	parentObj.oval(rx,ry,xradius,yradius);
	    	
	    	if (strokeDis!=-1){
		    	parentObj.strokeStyle = stroke;
		    	parentObj.stroke();
	    	}

	    	if (fillDis!=-1){
		    	parentObj.fillStyle = fill;
		    	parentObj.fill();
	    	}

    	]]>   
  	</method>  	
  	 
	<method name="drawellipse" args="x1,y1,x2,y2">
   		<![CDATA[
	   		//Debug.write("stroke,line: ",this.currentellipsestroke,this.currentellipselineWidth);
	    	var rx = (x1+x2)/2;
	    	var ry = (y1+y2)/2;
	    	var xradius = Math.abs(rx-x1);
	    	var yradius = Math.abs(ry-y1);
	    	
	    	currentlayer.lineWidth = this.currentellipselineWidth;
	    	currentlayer.oval(rx,ry,xradius,yradius);
	    	
	    	if (this.currentellipsestrokeDis!=-1){
		    	currentlayer.strokeStyle = this.currentellipsestroke;
		    	currentlayer.stroke();
	    	}
	    	
	    	if (this.currentellipsestrokeFillDis!=-1){
		    	currentlayer.fillStyle = this.currentellipsestrokeFill;
		    	currentlayer.fill(); 
	    	}
   	
    	]]>   
  	</method>
  	
  	<method name="drawellipseregisterFinal" args="newName,stroke,line,fill,strokeDis,fillDis,x,y,width,height" >
		var actionObject = new Array();
	    actionObject[0] = 'ellipse';
	    actionObject[1] = stroke;
	    actionObject[2] = line;
	    actionObject[3] = fill;
	    actionObject[4] = strokeDis;
	    actionObject[5] = fillDis;
		actionObject[6] = this.counter;
	    actionObject[7] = x;
	    actionObject[8] = y;
	    actionObject[9] = width;
	    actionObject[10] = height;	    
	    actionObject[11] = newName;
	    this.baseactionobjectList.push(actionObject);
	    this.onsharedMessage('draw',actionObject);
  	</method>  
  	
  	<!--- Selection Box -->
  	<method name="startDrawSelectionBox">
    	this.currentlayer = new lz.drawViewNew(this,{name:'selectionBox'+this.getCounter(),
    		typeOfObject:'selectionBox',
    		width:this.width+2,height:this.height+2});
        ////if ($debug) Debug.write("startDrawSelectionBox this.currentlayer: ",this.currentlayer);
  	</method>
  	
  	<method name="drawSelectionBox" args="x1,y1,x2,y2">
  		////if ($debug) Debug.write("this.currentlayer",this.currentlayer);
		this.currentlayer.lineWidth = 1;
		this.currentlayer.beginPath();
		this.currentlayer.setAttribute("opacity",0.5);
		this.currentlayer.fillStyle = 0xFFFFFF;
		this.currentlayer.strokeStyle = 0x000000;
		
		this.currentlayer.moveTo(x1,y1);
		this.currentlayer.lineTo(x1,y2);
		this.currentlayer.lineTo(x2,y2);
		this.currentlayer.lineTo(x2,y1);
		this.currentlayer.lineTo (x1,y1);
		this.currentlayer.closePath();
		
		this.currentlayer.stroke();
  	</method>
  	
  	<method name="endDrawSelectionBox">
        //if ($debug) Debug.write("endDrawSelectionBox this.currentlayer: ",this.currentlayer);
    	this.currentlayer.destroy();
  	</method>

  
</class>

</library>
